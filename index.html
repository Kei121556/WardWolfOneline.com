<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Wolf Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #7c3aed; /* Violet */
            --danger-color: #dc2626; /* Red */
            --background-color: #111827; /* Gray 900 */
            --card-bg: #1f2937; /* Gray 800 */
            --text-color: #f9fafb; /* Gray 50 */
            --border-color: #374151; /* Gray 700 */
        }
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            overscroll-behavior: none;
        }
        .screen {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 1rem;
            box-sizing: border-box;
            transition: opacity 0.5s ease-in-out;
        }
        .card {
            background-color: var(--card-bg);
            border-radius: 1rem;
            padding: 2rem;
            width: 100%;
            max-width: 500px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--border-color);
        }
        .btn {
            display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem;
            padding: 0.75rem 1.5rem; border-radius: 0.5rem; font-weight: 600;
            text-align: center; cursor: pointer; transition: all 0.2s ease-in-out; border: none;
        }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background-color: var(--primary-color); color: white; }
        .btn-primary:hover:not(:disabled) { background-color: #6d28d9; }
        .btn-secondary { background-color: #374151; color: white; }
        .btn-secondary:hover:not(:disabled) { background-color: #4b5563; }
        .form-input, .form-select {
            width: 100%; padding: 0.5rem 0.75rem; border-radius: 0.5rem;
            background-color: #374151; border: 1px solid #4b5563; color: white; margin-top: 0.25rem;
        }
        .timer { font-size: 4rem; font-weight: 700; line-height: 1; font-variant-numeric: tabular-nums; }
        @media (min-width: 640px) { .timer { font-size: 6rem; } }
        .rules-list { list-style-position: inside; text-align: left; }
        .rules-list li { margin-bottom: 0.5rem; }
    </style>
</head>
<body>
    <div id="app-container">
        <div class="screen">
            <div class="card text-center">
                <p class="text-2xl">Loading Game...</p>
            </div>
        </div>
    </div>

    <script type="module">
        const firebaseConfig = {
            apiKey: "AIzaSyB8AfXF8pVOQpW912jrBOuTzyB3BnUMHtc",
            authDomain: "wordwolfonline-com.firebaseapp.com",
            projectId: "wordwolfonline-com",
            storageBucket: "wordwolfonline-com.appspot.com",
            messagingSenderId: "831273321343",
            appId: "1:831273321343:web:c43481ad7b5cabf216504a"
        };

        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot, serverTimestamp, deleteDoc } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";

        const appContainer = document.getElementById('app-container');

        try {
            const app = initializeApp(firebaseConfig);
            const db = getFirestore(app);
            const auth = getAuth(app);

            let localState = {
                userId: null,
                playerName: localStorage.getItem('playerName') || '',
                roomId: null,
                isHost: false,
                roomUnsubscribe: null,
                timerInterval: null,
            };

            const TOPICS_EN = { food: [["Curry", "Stew"], ["Udon", "Soba"], ["Beer", "Low-malt Beer"], ["Apple", "Pear"], ["Macaron", "Fatcaron"], ["Sushi", "Sashimi"], ["Coffee", "Tea"], ["Steak", "Hamburger"], ["Pasta", "Pizza"], ["Pancake", "Waffle"], ["Chocolate", "Caramel"], ["Cheese", "Butter"]], places: [["Tokyo Tower", "Skytree"], ["Disneyland", "DisneySea"], ["Kinkaku-ji", "Ginkaku-ji"], ["Ocean", "River"], ["Convenience Store", "Supermarket"], ["Mountain", "Volcano"], ["School", "Hospital"], ["Museum", "Art Gallery"], ["Airport", "Train Station"], ["Park", "Garden"], ["Library", "Bookstore"], ["Cafe", "Restaurant"]], people: [["Actor", "Voice Actor"], ["Santa Claus", "Reindeer"], ["Teacher", "Student"], ["King", "President"], ["Scientist", "Inventor"], ["Artist", "Musician"], ["Chef", "PÃ¢tissier"], ["Athlete", "Coach"], ["Detective", "Police Officer"], ["YouTuber", "Streamer"], ["Pilot", "Astronaut"], ["Farmer", "Gardener"]], actions: [["Running", "Jogging"], ["Cooking", "Eating"], ["Sleeping", "Napping"], ["Studying", "Working"], ["Clapping", "Hand clapping"], ["Singing", "Dancing"], ["Reading", "Writing"], ["Drawing", "Painting"], ["Laughing", "Crying"], ["Walking", "Hiking"], ["Push", "Pull"], ["Throw", "Catch"]], things: [["Smartphone", "Cellphone"], ["Shampoo", "Conditioner"], ["PC", "Laptop"], ["Pencil", "Mechanical Pencil"], ["Umbrella", "Parasol"], ["Chair", "Sofa"], ["Book", "Magazine"], ["Key", "Lock"], ["Watch", "Clock"], ["Glasses", "Sunglasses"], ["Spoon", "Fork"], ["Towel", "Blanket"]], sports: [["Soccer", "Futsal"], ["Baseball", "Softball"], ["Tennis", "Badminton"], ["Table Tennis", "Ping-Pong"], ["Swimming", "Diving"], ["Skiing", "Snowboarding"], ["Basketball", "Volleyball"], ["Judo", "Karate"], ["Golf", "Bowling"], ["Boxing", "Wrestling"], ["Skateboarding", "Surfing"], ["Archery", "Darts"]], entertainment: [["Movie", "Drama"], ["Manga", "Anime"], ["Theater", "Musical"], ["YouTube", "TikTok"], ["Concert", "Festival"], ["Comedy", "Tragedy"], ["Radio", "Podcast"], ["Circus", "Magic Show"], ["Ballet", "Opera"], ["Video Game", "Arcade Game"], ["Novel", "Poem"], ["Sculpture", "Painting"]], animals: [["Dog", "Cat"], ["Lion", "Tiger"], ["Dolphin", "Whale"], ["Hamster", "Guinea Pig"], ["Horse", "Zebra"], ["Chicken", "Duck"], ["Snake", "Lizard"], ["Butterfly", "Moth"], ["Spider", "Scorpion"], ["Rabbit", "Hare"], ["Penguin", "Ostrich"], ["Frog", "Toad"]], nature: [["Sun", "Moon"], ["Mountain", "Hill"], ["Spring", "Autumn"], ["Thunder", "Lightning"], ["Cloud", "Fog"], ["Rain", "Snow"], ["Wind", "Breeze"], ["Star", "Planet"], ["Forest", "Jungle"], ["Desert", "Oasis"], ["River", "Lake"], ["Volcano", "Geyser"]], tech: [["AI", "Robot"], ["Internet", "Intranet"], ["VR", "AR"], ["Programming", "Coding"], ["Drone", "Helicopter"], ["Email", "Letter"], ["Headphones", "Earphones"], ["Camera", "Video Camera"], ["Printer", "Scanner"], ["Tablet", "e-Reader"], ["Mouse", "Keyboard"], ["Battery", "Charger"]], fantasy: [["Wizard", "Witch"], ["Dragon", "Wyvern"], ["Elf", "Dwarf"], ["Hero", "Demon Lord"], ["Ghost", "Zombie"], ["Angel", "Demon"], ["Unicorn", "Pegasus"], ["Vampire", "Werewolf"], ["Mermaid", "Siren"], ["Fairy", "Goblin"], ["Phoenix", "Griffin"], ["Potion", "Spell"]], games: [["Mario", "Luigi"], ["Final Fantasy", "Dragon Quest"], ["Puzzle", "Quiz"], ["Board Game", "Card Game"], ["PokÃ©mon", "Digimon"], ["Minecraft", "Roblox"], ["Chess", "Shogi"], ["Tag", "Hide-and-seek"], ["Poker", "Blackjack"], ["Billiards", "Darts"], ["Monopoly", "Scrabble"], ["Tetris", "Pac-Man"]], history: [["Rome", "Greece"], ["Knight", "Samurai"], ["Pyramid", "Sphinx"], ["World War I", "World War II"], ["Renaissance", "Industrial Revolution"], ["Castle", "Fortress"], ["Viking", "Pirate"], ["Dinosaur", "Mammoth"], ["King", "Emperor"], ["Revolution", "Rebellion"], ["Napoleon", "Caesar"], ["Cleopatra", "Joan of Arc"]], jobs: [["Doctor", "Nurse"], ["Police Officer", "Firefighter"], ["Baker", "PÃ¢tissier"], ["Pilot", "Cabin Attendant"], ["Lawyer", "Prosecutor"], ["Writer", "Journalist"], ["Designer", "Architect"], ["Farmer", "Fisherman"], ["Singer", "Dancer"], ["Engineer", "Mechanic"], ["Photographer", "Videographer"], ["Librarian", "Curator"]], colors: [["Red", "Pink"], ["Black", "Navy"], ["Gold", "Silver"], ["Orange", "Brown"], ["Green", "Lime"], ["Blue", "Sky Blue"], ["Purple", "Lavender"], ["White", "Ivory"], ["Gray", "Charcoal"], ["Beige", "Cream"], ["Turquoise", "Teal"], ["Magenta", "Fuchsia"]], uk: [["Big Ben", "Tower of London"], ["Buckingham Palace", "Windsor Castle"], ["Football", "Rugby"], ["Fish and Chips", "Shepherd's Pie"], ["The Beatles", "The Rolling Stones"], ["Sherlock Holmes", "James Bond"], ["Tea", "Afternoon Tea"], ["England", "Scotland"], ["House of Commons", "House of Lords"], ["Harry Potter", "The Lord of the Rings"], ["Queen", "Oasis"], ["Wimbledon", "The Open Championship"], ["Stonehenge", "Hadrian's Wall"], ["The British Museum", "The National Gallery"], ["Tower Bridge", "London Bridge"], ["Edinburgh Castle", "Cardiff Castle"], ["London", "Manchester"], ["Scone", "Crumpet"], ["Gin", "Whisky"], ["Prince", "Princess"], ["Double-decker bus", "Black cab"], ["King Arthur", "Robin Hood"], ["Thames River", "River Severn"], ["London Eye", "The Shard"], ["Cheddar cheese", "Stilton cheese"], ["Red telephone box", "Red post box"], ["Shakespeare", "Charles Dickens"], ["Oxford University", "Cambridge University"], ["Paddington Bear", "Winnie-the-Pooh"], ["Jaffa Cakes", "Digestive Biscuits"], ["Union Jack", "Flag of England"]] };
            const TOPICS_JA = { food: [["ã‚«ãƒ¬ãƒ¼", "ã‚·ãƒãƒ¥ãƒ¼"], ["ã†ã©ã‚“", "ãã°"], ["ãƒ“ãƒ¼ãƒ«", "ç™ºæ³¡é…’"], ["ã‚Šã‚“ã”", "ãªã—"], ["ãƒã‚«ãƒ­ãƒ³", "ãƒˆã‚¥ãƒ³ã‚«ãƒ­ãƒ³"], ["å¯¿å¸", "åˆºèº«"], ["ã‚³ãƒ¼ãƒ’ãƒ¼", "ç´…èŒ¶"], ["ã‚¹ãƒ†ãƒ¼ã‚­", "ãƒãƒ³ãƒãƒ¼ã‚°"], ["ãƒ‘ã‚¹ã‚¿", "ãƒ”ã‚¶"], ["ãƒ‘ãƒ³ã‚±ãƒ¼ã‚­", "ãƒ¯ãƒƒãƒ•ãƒ«"], ["ãƒãƒ§ã‚³ãƒ¬ãƒ¼ãƒˆ", "ã‚­ãƒ£ãƒ©ãƒ¡ãƒ«"], ["ãƒãƒ¼ã‚º", "ãƒã‚¿ãƒ¼"]], places: [["æ±äº¬ã‚¿ãƒ¯ãƒ¼", "ã‚¹ã‚«ã‚¤ãƒ„ãƒªãƒ¼"], ["ãƒ‡ã‚£ã‚ºãƒ‹ãƒ¼ãƒ©ãƒ³ãƒ‰", "ãƒ‡ã‚£ã‚ºãƒ‹ãƒ¼ã‚·ãƒ¼"], ["é‡‘é–£å¯º", "éŠ€é–£å¯º"], ["æµ·", "å·"], ["ã‚³ãƒ³ãƒ“ãƒ‹", "ã‚¹ãƒ¼ãƒ‘ãƒ¼"], ["å±±", "ç«å±±"], ["å­¦æ ¡", "ç—…é™¢"], ["åšç‰©é¤¨", "ç¾è¡“é¤¨"], ["ç©ºæ¸¯", "é§…"], ["å…¬åœ’", "åº­åœ’"], ["å›³æ›¸é¤¨", "æœ¬å±‹"], ["ã‚«ãƒ•ã‚§", "ãƒ¬ã‚¹ãƒˆãƒ©ãƒ³"]], people: [["ä¿³å„ª", "å£°å„ª"], ["ã‚µãƒ³ã‚¿ã‚¯ãƒ­ãƒ¼ã‚¹", "ãƒˆãƒŠã‚«ã‚¤"], ["å…ˆç”Ÿ", "ç”Ÿå¾’"], ["ç‹æ§˜", "å¤§çµ±é ˜"], ["ç§‘å­¦è€…", "ç™ºæ˜å®¶"], ["èŠ¸è¡“å®¶", "éŸ³æ¥½å®¶"], ["ã‚·ã‚§ãƒ•", "ãƒ‘ãƒ†ã‚£ã‚·ã‚¨"], ["ã‚¹ãƒãƒ¼ãƒ„é¸æ‰‹", "ã‚³ãƒ¼ãƒ"], ["æ¢åµ", "è­¦å¯Ÿå®˜"], ["YouTuber", "é…ä¿¡è€…"], ["ãƒ‘ã‚¤ãƒ­ãƒƒãƒˆ", "å®‡å®™é£›è¡Œå£«"], ["è¾²å®¶", "åº­å¸«"]], actions: [["ãƒ©ãƒ³ãƒ‹ãƒ³ã‚°", "ã‚¸ãƒ§ã‚®ãƒ³ã‚°"], ["æ–™ç†", "é£Ÿäº‹"], ["ç¡çœ ", "æ˜¼å¯"], ["å‹‰å¼·", "ä»•äº‹"], ["æ‹æ‰‹", "æ‰‹æ‹å­"], ["æ­Œ", "ãƒ€ãƒ³ã‚¹"], ["èª­æ›¸", "åŸ·ç­†"], ["æç”»", "çµµç”»"], ["ç¬‘ã†", "æ³£ã"], ["æ­©ã", "ãƒã‚¤ã‚­ãƒ³ã‚°"], ["æŠ¼ã™", "å¼•ã"], ["æŠ•ã’ã‚‹", "ã‚­ãƒ£ãƒƒãƒã™ã‚‹"]], things: [["ã‚¹ãƒãƒ›", "æºå¸¯é›»è©±"], ["ã‚·ãƒ£ãƒ³ãƒ—ãƒ¼", "ãƒªãƒ³ã‚¹"], ["ãƒ‘ã‚½ã‚³ãƒ³", "ãƒãƒ¼ãƒˆãƒ‘ã‚½ã‚³ãƒ³"], ["é‰›ç­†", "ã‚·ãƒ£ãƒ¼ãƒšãƒ³"], ["å‚˜", "æ—¥å‚˜"], ["æ¤…å­", "ã‚½ãƒ•ã‚¡"], ["æœ¬", "é›‘èªŒ"], ["éµ", "éŒ "], ["è…•æ™‚è¨ˆ", "æ™‚è¨ˆ"], ["ãƒ¡ã‚¬ãƒ", "ã‚µãƒ³ã‚°ãƒ©ã‚¹"], ["ã‚¹ãƒ—ãƒ¼ãƒ³", "ãƒ•ã‚©ãƒ¼ã‚¯"], ["ã‚¿ã‚ªãƒ«", "æ¯›å¸ƒ"]], sports: [["ã‚µãƒƒã‚«ãƒ¼", "ãƒ•ãƒƒãƒˆã‚µãƒ«"], ["é‡çƒ", "ã‚½ãƒ•ãƒˆãƒœãƒ¼ãƒ«"], ["ãƒ†ãƒ‹ã‚¹", "ãƒãƒ‰ãƒŸãƒ³ãƒˆãƒ³"], ["å“çƒ", "ãƒ”ãƒ³ãƒãƒ³"], ["æ°´æ³³", "é£›ã³è¾¼ã¿"], ["ã‚¹ã‚­ãƒ¼", "ã‚¹ãƒãƒ¼ãƒœãƒ¼ãƒ‰"], ["ãƒã‚¹ã‚±ãƒƒãƒˆãƒœãƒ¼ãƒ«", "ãƒãƒ¬ãƒ¼ãƒœãƒ¼ãƒ«"], ["æŸ”é“", "ç©ºæ‰‹"], ["ã‚´ãƒ«ãƒ•", "ãƒœã‚¦ãƒªãƒ³ã‚°"], ["ãƒœã‚¯ã‚·ãƒ³ã‚°", "ãƒ¬ã‚¹ãƒªãƒ³ã‚°"], ["ã‚¹ã‚±ãƒ¼ãƒˆãƒœãƒ¼ãƒ‰", "ã‚µãƒ¼ãƒ•ã‚£ãƒ³"], ["ã‚¢ãƒ¼ãƒã‚§ãƒªãƒ¼", "ãƒ€ãƒ¼ãƒ„"]], entertainment: [["æ˜ ç”»", "ãƒ‰ãƒ©ãƒ"], ["æ¼«ç”»", "ã‚¢ãƒ‹ãƒ¡"], ["æ¼”åŠ‡", "ãƒŸãƒ¥ãƒ¼ã‚¸ã‚«ãƒ«"], ["YouTube", "TikTok"], ["ã‚³ãƒ³ã‚µãƒ¼ãƒˆ", "ãƒ•ã‚§ã‚¹"], ["å–œåŠ‡", "æ‚²åŠ‡"], ["ãƒ©ã‚¸ã‚ª", "ãƒãƒƒãƒ‰ã‚­ãƒ£ã‚¹ãƒˆ"], ["ã‚µãƒ¼ã‚«ã‚¹", "ãƒã‚¸ãƒƒã‚¯ã‚·ãƒ§ãƒ¼"], ["ãƒãƒ¬ã‚¨", "ã‚ªãƒšãƒ©"], ["ãƒ†ãƒ¬ãƒ“ã‚²ãƒ¼ãƒ ", "ã‚¢ãƒ¼ã‚±ãƒ¼ãƒ‰ã‚²ãƒ¼ãƒ "], ["å°èª¬", "è©©"], ["å½«åˆ»", "çµµç”»"]], animals: [["çŠ¬", "çŒ«"], ["ãƒ©ã‚¤ã‚ªãƒ³", "ãƒˆãƒ©"], ["ã‚¤ãƒ«ã‚«", "ã‚¯ã‚¸ãƒ©"], ["ãƒãƒ ã‚¹ã‚¿ãƒ¼", "ãƒ¢ãƒ«ãƒ¢ãƒƒãƒˆ"], ["é¦¬", "ã‚·ãƒã‚¦ãƒ"], ["ãƒ‹ãƒ¯ãƒˆãƒª", "ã‚¢ãƒ’ãƒ«"], ["ãƒ˜ãƒ“", "ãƒˆã‚«ã‚²"], ["è¶", "è›¾"], ["ã‚¯ãƒ¢", "ã‚µã‚½ãƒª"], ["ã†ã•ã", "é‡ã†ã•ã"], ["ãƒšãƒ³ã‚®ãƒ³", "ãƒ€ãƒãƒ§ã‚¦"], ["ã‚«ã‚¨ãƒ«", "ãƒ’ã‚­ã‚¬ã‚¨ãƒ«"]], nature: [["å¤ªé™½", "æœˆ"], ["å±±", "ä¸˜"], ["æ˜¥", "ç§‹"], ["é›·", "ç¨²å¦»"], ["é›²", "éœ§"], ["é›¨", "é›ª"], ["é¢¨", "ãã‚ˆé¢¨"], ["æ˜Ÿ", "æƒ‘æ˜Ÿ"], ["æ£®", "ã‚¸ãƒ£ãƒ³ã‚°ãƒ«"], ["ç ‚æ¼ ", "ã‚ªã‚¢ã‚·ã‚¹"], ["å·", "æ¹–"], ["ç«å±±", "é–“æ¬ æ³‰"]], tech: [["AI", "ãƒ­ãƒœãƒƒãƒˆ"], ["ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆ", "ã‚¤ãƒ³ãƒˆãƒ©ãƒãƒƒãƒˆ"], ["VR", "AR"], ["ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°", "ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°"], ["ãƒ‰ãƒ­ãƒ¼ãƒ³", "ãƒ˜ãƒªã‚³ãƒ—ã‚¿ãƒ¼"], ["Eãƒ¡ãƒ¼ãƒ«", "æ‰‹ç´™"], ["ãƒ˜ãƒƒãƒ‰ãƒ›ãƒ³", "ã‚¤ãƒ¤ãƒ›ãƒ³"], ["ã‚«ãƒ¡ãƒ©", "ãƒ“ãƒ‡ã‚ªã‚«ãƒ¡ãƒ©"], ["ãƒ—ãƒªãƒ³ã‚¿ãƒ¼", "ã‚¹ã‚­ãƒ£ãƒŠãƒ¼"], ["ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆ", "é›»å­æ›¸ç±ãƒªãƒ¼ãƒ€ãƒ¼"], ["ãƒã‚¦ã‚¹", "ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰"], ["ãƒãƒƒãƒ†ãƒªãƒ¼", "å……é›»å™¨"]], fantasy: [["é­”æ³•ä½¿ã„", "é­”å¥³"], ["ãƒ‰ãƒ©ã‚´ãƒ³", "ãƒ¯ã‚¤ãƒãƒ¼ãƒ³"], ["ã‚¨ãƒ«ãƒ•", "ãƒ‰ãƒ¯ãƒ¼ãƒ•"], ["å‹‡è€…", "é­”ç‹"], ["å¹½éœŠ", "ã‚¾ãƒ³ãƒ“"], ["å¤©ä½¿", "æ‚ªé­”"], ["ãƒ¦ãƒ‹ã‚³ãƒ¼ãƒ³", "ãƒšã‚¬ã‚µã‚¹"], ["å¸è¡€é¬¼", "ç‹¼ç”·"], ["äººé­š", "ã‚»ã‚¤ãƒ¬ãƒ¼ãƒ³"], ["å¦–ç²¾", "ã‚´ãƒ–ãƒªãƒ³"], ["ãƒ•ã‚§ãƒ‹ãƒƒã‚¯ã‚¹", "ã‚°ãƒªãƒ•ã‚£ãƒ³"], ["ãƒãƒ¼ã‚·ãƒ§ãƒ³", "å‘ªæ–‡"]], games: [["ãƒãƒªã‚ª", "ãƒ«ã‚¤ãƒ¼ã‚¸"], ["ãƒ•ã‚¡ã‚¤ãƒŠãƒ«ãƒ•ã‚¡ãƒ³ã‚¿ã‚¸ãƒ¼", "ãƒ‰ãƒ©ã‚´ãƒ³ã‚¯ã‚¨ã‚¹ãƒˆ"], ["ãƒ‘ã‚ºãƒ«", "ã‚¯ã‚¤ã‚º"], ["ãƒœãƒ¼ãƒ‰ã‚²ãƒ¼ãƒ ", "ã‚«ãƒ¼ãƒ‰ã‚²ãƒ¼ãƒ "], ["ãƒã‚±ãƒ¢ãƒ³", "ãƒ‡ã‚¸ãƒ¢ãƒ³"], ["ãƒã‚¤ãƒ³ã‚¯ãƒ©ãƒ•ãƒˆ", "ãƒ­ãƒ–ãƒ­ãƒƒã‚¯ã‚¹"], ["ãƒã‚§ã‚¹", "å°†æ£‹"], ["é¬¼ã”ã£ã“", "ã‹ãã‚Œã‚“ã¼"], ["ãƒãƒ¼ã‚«ãƒ¼", "ãƒ–ãƒ©ãƒƒã‚¯ã‚¸ãƒ£ãƒƒã‚¯"], ["ãƒ“ãƒªãƒ¤ãƒ¼ãƒ‰", "ãƒ€ãƒ¼ãƒ„"], ["ãƒ¢ãƒãƒãƒªãƒ¼", "ã‚¹ã‚¯ãƒ©ãƒ–ãƒ«"], ["ãƒ†ãƒˆãƒªã‚¹", "ãƒ‘ãƒƒã‚¯ãƒãƒ³"]], history: [["ãƒ­ãƒ¼ãƒ", "ã‚®ãƒªã‚·ãƒ£"], ["é¨å£«", "ä¾"], ["ãƒ”ãƒ©ãƒŸãƒƒãƒ‰", "ã‚¹ãƒ•ã‚£ãƒ³ã‚¯ã‚¹"], ["ç¬¬ä¸€æ¬¡ä¸–ç•Œå¤§æˆ¦", "ç¬¬äºŒæ¬¡ä¸–ç•Œå¤§æˆ¦"], ["ãƒ«ãƒã‚µãƒ³ã‚¹", "ç”£æ¥­é©å‘½"], ["åŸ", "è¦å¡"], ["ãƒã‚¤ã‚­ãƒ³ã‚°", "æµ·è³Š"], ["æç«œ", "ãƒãƒ³ãƒ¢ã‚¹"], ["ç‹", "çš‡å¸"], ["é©å‘½", "åä¹±"], ["ãƒŠãƒãƒ¬ã‚ªãƒ³", "ã‚«ã‚¨ã‚µãƒ«"], ["ã‚¯ãƒ¬ã‚ªãƒ‘ãƒˆãƒ©", "ã‚¸ãƒ£ãƒ³ãƒŒãƒ»ãƒ€ãƒ«ã‚¯"]], jobs: [["åŒ»è€…", "çœ‹è­·å¸«"], ["è­¦å¯Ÿå®˜", "æ¶ˆé˜²å£«"], ["ãƒ‘ãƒ³å±‹", "ãƒ‘ãƒ†ã‚£ã‚·ã‚¨"], ["ãƒ‘ã‚¤ãƒ­ãƒƒãƒˆ", "å®¢å®¤ä¹—å‹™å“¡"], ["å¼è­·å£«", "æ¤œå¯Ÿå®˜"], ["ä½œå®¶", "ã‚¸ãƒ£ãƒ¼ãƒŠãƒªã‚¹ãƒˆ"], ["ãƒ‡ã‚¶ã‚¤ãƒŠãƒ¼", "å»ºç¯‰å®¶"], ["è¾²å®¶", "æ¼å¸«"], ["æ­Œæ‰‹", "ãƒ€ãƒ³ã‚µãƒ¼"], ["ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢", "æ•´å‚™å£«"], ["å†™çœŸå®¶", "ãƒ“ãƒ‡ã‚ªã‚°ãƒ©ãƒ•ã‚¡ãƒ¼"], ["å¸æ›¸", "å­¦èŠ¸å“¡"]], colors: [["èµ¤", "ãƒ”ãƒ³ã‚¯"], ["é»’", "ç´º"], ["é‡‘", "éŠ€"], ["ã‚ªãƒ¬ãƒ³ã‚¸", "èŒ¶è‰²"], ["ç·‘", "é»„ç·‘"], ["é’", "æ°´è‰²"], ["ç´«", "ãƒ©ãƒ™ãƒ³ãƒ€ãƒ¼"], ["ç™½", "ã‚¢ã‚¤ãƒœãƒªãƒ¼"], ["ç°è‰²", "ãƒãƒ£ã‚³ãƒ¼ãƒ«"], ["ãƒ™ãƒ¼ã‚¸ãƒ¥", "ã‚¯ãƒªãƒ¼ãƒ è‰²"], ["ã‚¿ãƒ¼ã‚³ã‚¤ã‚º", "ãƒ†ã‚£ãƒ¼ãƒ«"], ["ãƒã‚¼ãƒ³ã‚¿", "ãƒ•ãƒ¥ãƒ¼ã‚·ãƒ£"]], uk: [["ãƒ“ãƒƒã‚°ãƒ»ãƒ™ãƒ³", "ãƒ­ãƒ³ãƒ‰ãƒ³å¡”"], ["ãƒãƒƒã‚­ãƒ³ã‚¬ãƒ å®®æ®¿", "ã‚¦ã‚£ãƒ³ã‚¶ãƒ¼åŸ"], ["ã‚µãƒƒã‚«ãƒ¼", "ãƒ©ã‚°ãƒ“ãƒ¼"], ["ãƒ•ã‚£ãƒƒã‚·ãƒ¥ãƒ»ã‚¢ãƒ³ãƒ‰ãƒ»ãƒãƒƒãƒ—ã‚¹", "ã‚·ã‚§ãƒ‘ãƒ¼ã‚ºãƒ‘ã‚¤"], ["ãƒ“ãƒ¼ãƒˆãƒ«ã‚º", "ãƒ­ãƒ¼ãƒªãƒ³ã‚°ãƒ»ã‚¹ãƒˆãƒ¼ãƒ³ã‚º"], ["ã‚·ãƒ£ãƒ¼ãƒ­ãƒƒã‚¯ãƒ»ãƒ›ãƒ¼ãƒ ã‚º", "ã‚¸ã‚§ãƒ¼ãƒ ã‚ºãƒ»ãƒœãƒ³ãƒ‰"], ["ç´…èŒ¶", "ã‚¢ãƒ•ã‚¿ãƒŒãƒ¼ãƒ³ãƒ†ã‚£ãƒ¼"], ["ã‚¤ãƒ³ã‚°ãƒ©ãƒ³ãƒ‰", "ã‚¹ã‚³ãƒƒãƒˆãƒ©ãƒ³ãƒ‰"], ["åº¶æ°‘é™¢", "è²´æ—é™¢"], ["ãƒãƒªãƒ¼ãƒ»ãƒãƒƒã‚¿ãƒ¼", "æŒ‡è¼ªç‰©èª"], ["ã‚¯ã‚¤ãƒ¼ãƒ³", "ã‚ªã‚¢ã‚·ã‚¹"], ["ã‚¦ã‚£ãƒ³ãƒ–ãƒ«ãƒ‰ãƒ³", "å…¨è‹±ã‚ªãƒ¼ãƒ—ãƒ³"], ["ã‚¹ãƒˆãƒ¼ãƒ³ãƒ˜ãƒ³ã‚¸", "ãƒãƒ‰ãƒªã‚¢ãƒŒã‚¹ã®é•·åŸ"], ["å¤§è‹±åšç‰©é¤¨", "ãƒŠã‚·ãƒ§ãƒŠãƒ«ãƒ»ã‚®ãƒ£ãƒ©ãƒªãƒ¼"], ["ã‚¿ãƒ¯ãƒ¼ãƒ–ãƒªãƒƒã‚¸", "ãƒ­ãƒ³ãƒ‰ãƒ³æ©‹"], ["ã‚¨ãƒ‡ã‚£ãƒ³ãƒãƒ©åŸ", "ã‚«ãƒ¼ãƒ‡ã‚£ãƒ•åŸ"], ["ãƒ­ãƒ³ãƒ‰ãƒ³", "ãƒãƒ³ãƒã‚§ã‚¹ã‚¿ãƒ¼"], ["ã‚¹ã‚³ãƒ¼ãƒ³", "ã‚¯ãƒ©ãƒ³ãƒšãƒƒãƒˆ"], ["ã‚¸ãƒ³", "ã‚¦ã‚£ã‚¹ã‚­ãƒ¼"], ["ç‹å­", "ç‹å¥³"], ["äºŒéšå»ºã¦ãƒã‚¹", "ãƒ–ãƒ©ãƒƒã‚¯ã‚­ãƒ£ãƒ–"], ["ã‚¢ãƒ¼ã‚µãƒ¼ç‹", "ãƒ­ãƒ“ãƒ³ãƒ»ãƒ•ãƒƒãƒ‰"], ["ãƒ†ãƒ ã‚ºå·", "ã‚»ãƒ´ã‚¡ãƒ¼ãƒ³å·"], ["ãƒ­ãƒ³ãƒ‰ãƒ³ãƒ»ã‚¢ã‚¤", "ã‚¶ãƒ»ã‚·ãƒ£ãƒ¼ãƒ‰"], ["ãƒã‚§ãƒ€ãƒ¼ãƒãƒ¼ã‚º", "ã‚¹ãƒ†ã‚£ãƒ«ãƒˆãƒ³ãƒãƒ¼ã‚º"], ["èµ¤ã„é›»è©±ãƒœãƒƒã‚¯ã‚¹", "èµ¤ã„éƒµä¾¿ãƒã‚¹ãƒˆ"], ["ã‚·ã‚§ã‚¤ã‚¯ã‚¹ãƒ”ã‚¢", "ãƒãƒ£ãƒ¼ãƒ«ã‚ºãƒ»ãƒ‡ã‚£ã‚±ãƒ³ã‚º"], ["ã‚ªãƒƒã‚¯ã‚¹ãƒ•ã‚©ãƒ¼ãƒ‰å¤§å­¦", "ã‚±ãƒ³ãƒ–ãƒªãƒƒã‚¸å¤§å­¦"], ["ãƒ‘ãƒ‡ã‚£ãƒ³ãƒˆãƒ³", "ãã¾ã®ãƒ—ãƒ¼ã•ã‚“"], ["ã‚¸ãƒ£ãƒ•ã‚¡ã‚±ãƒ¼ã‚­", "ãƒ€ã‚¤ã‚¸ã‚§ã‚¹ãƒ†ã‚£ãƒ–ãƒ“ã‚¹ã‚±ãƒƒãƒˆ"], ["ãƒ¦ãƒ‹ã‚ªãƒ³ã‚¸ãƒ£ãƒƒã‚¯", "ã‚¤ãƒ³ã‚°ãƒ©ãƒ³ãƒ‰ã®æ——"]] };
            const TOPIC_NAMES_EN = { food: "Food & Drink", places: "Places", people: "People", actions: "Actions", things: "Things", sports: "Sports", entertainment: "Entertainment", animals: "Animals", nature: "Nature", tech: "Technology", fantasy: "Fantasy", games: "Games", history: "History", jobs: "Jobs", colors: "Colors", uk: "About the UK" };
            const TOPIC_NAMES_JA = { food: "é£Ÿã¹ç‰©ãƒ»é£²ã¿ç‰©", places: "å ´æ‰€", people: "äººç‰©", actions: "è¡Œå‹•", things: "ãƒ¢ãƒ", sports: "ã‚¹ãƒãƒ¼ãƒ„", entertainment: "ã‚¨ãƒ³ã‚¿ãƒ¡", animals: "å‹•ç‰©", nature: "è‡ªç„¶", tech: "ãƒ†ã‚¯ãƒãƒ­ã‚¸ãƒ¼", fantasy: "ãƒ•ã‚¡ãƒ³ã‚¿ã‚¸ãƒ¼", games: "ã‚²ãƒ¼ãƒ ", history: "æ­´å²", jobs: "è·æ¥­", colors: "è‰²", uk: "ã‚¤ã‚®ãƒªã‚¹é–¢é€£" };

            function render(html) { appContainer.innerHTML = html; }

            // --- UI TEMPLATES ---

            function getHomeScreenHTML() {
                return `
                    <div class="screen">
                        <div class="card text-center">
                            <h1 class="text-4xl font-bold text-violet-400">Word Wolf</h1>
                            <p class="text-gray-400 mt-2 mb-8">The Ultimate Word Finding Game</p>
                            <div class="space-y-4">
                                <input type="text" id="player-name-input" class="form-input text-center" placeholder="Enter your name" value="${localState.playerName}">
                                <button id="create-room-btn" class="btn btn-primary w-full">Create Room</button>
                                <div class="flex items-center gap-2">
                                    <input type="text" id="join-room-id-input" class="form-input text-center" placeholder="Room ID">
                                    <button id="join-room-btn" class="btn btn-secondary">Join</button>
                                </div>
                            </div>
                            <button id="show-rules-btn" class="text-violet-400 mt-8">How to Play & Credits</button>
                        </div>
                    </div>
                `;
            }

            function getRulesAndCreditsHTML() {
                 return `
                    <div class="screen">
                        <div class="card">
                            <div class="text-center mb-6"><h1 class="text-3xl font-bold">Word Wolf</h1></div>
                            <div class="space-y-6">
                                <div>
                                    <h2 class="text-xl font-bold mb-2 text-violet-400">What is Word Wolf?</h2>
                                    <p class="text-gray-300">It's a game to find the "wolf" who has been given a different word from everyone else (the "citizens"). Use discussion to find the person who doesn't quite fit in!</p>
                                </div>
                                <div>
                                    <h2 class="text-xl font-bold mb-2 text-violet-400">Game Flow</h2>
                                    <ol class="list-decimal rules-list space-y-2 text-gray-300">
                                        <li><b>Setup:</b> The host sets the game rules in the waiting room.</li>
                                        <li><b>Check Word:</b> Secretly check your assigned word. You won't be told your role!</li>
                                        <li><b>Talk Time:</b> Discuss the topic to find the wolf.</li>
                                        <li><b>Question Time:</b> One by one, ask a question or skip your turn.</li>
                                        <li><b>Final Talk Time:</b> One last chance to discuss before the vote.</li>
                                        <li><b>Vote:</b> Vote for who you think is the Wolf.</li>
                                        <li><b>Result:</b> See who was eliminated and if the game ends!</li>
                                    </ol>
                                </div>
                                <div>
                                    <h2 class="text-xl font-bold mb-2 text-violet-400">Credits</h2>
                                    <div class="text-gray-400 text-sm text-center space-y-1">
                                        <p>Game Director: Kei</p>
                                        <p>Development: KY</p>
                                        <p>Development Support: Gemini</p>
                                    </div>
                                </div>
                                <button id="back-to-home-btn" class="btn btn-primary w-full mt-4">Back</button>
                            </div>
                        </div>
                    </div>
                `;
            }

            function getWaitingRoomHTML(room) {
                const isHost = room.hostId === localState.userId;
                const playersHTML = Object.values(room.players).map(p => `<span class="p-2 rounded-full bg-gray-700">${p.name} ${p.isHost ? 'ğŸ‘‘' : ''}</span>`).join('');
                const topicNames = room.settings.language === 'ja' ? TOPIC_NAMES_JA : TOPIC_NAMES_EN;
                const topicOptionsHTML = Object.keys(topicNames).map(key => `<option value="${key}" ${room.settings.topic === key ? 'selected' : ''}>${topicNames[key]}</option>`).join('');

                return `
                    <div class="screen">
                        <div class="card text-center">
                            <p class="text-gray-400">Room ID</p>
                            <div class="bg-gray-900 p-3 rounded-md font-mono text-2xl tracking-widest my-2 cursor-pointer" id="room-id-display">${room.id}</div>
                            <p id="copy-feedback" class="text-sm text-green-400 h-4"></p>
                            <h2 class="text-xl font-bold mt-6 mb-3">Players (${Object.keys(room.players).length})</h2>
                            <div class="flex flex-wrap justify-center gap-2 mb-6">${playersHTML}</div>
                            ${isHost ? `
                                <div class="text-left space-y-4 mt-4 border-t border-gray-700 pt-4">
                                    <div>
                                        <label for="language" class="font-medium">Language</label>
                                        <select id="language" class="form-select">
                                            <option value="en" ${room.settings.language === 'en' ? 'selected' : ''}>English</option>
                                            <option value="ja" ${room.settings.language === 'ja' ? 'selected' : ''}>æ—¥æœ¬èª</option>
                                        </select>
                                    </div>
                                    <div class="grid grid-cols-2 gap-4">
                                        <div>
                                            <label for="wolf-count" class="font-medium">Wolf Count</label>
                                            <input id="wolf-count" type="number" class="form-input" value="${room.settings.wolfCount}" min="1">
                                        </div>
                                        <div>
                                            <label for="turn-count" class="font-medium">Rounds</label>
                                            <input id="turn-count" type="number" class="form-input" value="${room.settings.turnCount}" min="1" max="5">
                                        </div>
                                    </div>
                                     <div class="grid grid-cols-2 gap-4">
                                        <div>
                                            <label for="talk-time" class="font-medium">Talk Time (sec)</label>
                                            <input id="talk-time" type="number" class="form-input" value="${room.settings.talkTime}" min="10">
                                        </div>
                                        <div>
                                            <label for="final-talk-time" class="font-medium">Final Talk (sec)</label>
                                            <input id="final-talk-time" type="number" class="form-input" value="${room.settings.finalTalkTime}" min="10">
                                        </div>
                                    </div>
                                    <div>
                                        <label for="topic" class="font-medium">Topic</label>
                                        <select id="topic" class="form-select">
                                            ${topicOptionsHTML}
                                            <option value="custom" ${room.settings.topic === 'custom' ? 'selected' : ''}>Custom</option>
                                        </select>
                                    </div>
                                    <div id="custom-topic-area" class="${room.settings.topic === 'custom' ? '' : 'hidden'} space-y-2">
                                        <div id="custom-pairs-container">
                                            <!-- Custom pairs will be injected here -->
                                        </div>
                                        <button id="add-pair-btn" class="btn btn-secondary w-full text-sm py-2">Add Pair</button>
                                    </div>
                                </div>
                                <button id="start-game-btn" class="btn btn-primary w-full mt-6">Start Game</button>
                            ` : '<p class="text-gray-400 mt-6">Waiting for the host to start the game...</p>'}
                        </div>
                    </div>
                `;
            }

            function getRoleAssignmentHTML(room) {
                const me = room.players[localState.userId];
                return `
                    <div class="screen">
                        <div class="card text-center">
                            <p class="text-gray-400 mt-6">Your Word is</p>
                            <p class="text-4xl font-bold text-violet-400 my-4">${me.word}</p>
                            <button id="ack-word-btn" class="btn btn-primary w-full">I Understand</button>
                        </div>
                    </div>
                `;
            }
            
            function getTalkTimeHTML(room) {
                const playersHTML = Object.values(room.players).map(p => {
                    const isEliminated = p.isEliminated ? 'line-through opacity-50' : '';
                    return `<span class="p-2 rounded-full bg-gray-700 ${isEliminated}">${p.name}</span>`;
                }).join('');
                const title = room.gameState === 'final_talk_time' ? 'Final Talk Time' : 'Talk Time';
                return `
                    <div class="screen">
                        <div class="card text-center w-full max-w-2xl">
                            <p class="text-2xl font-bold mb-4">${title} (Round ${room.currentTurn})</p>
                            <div id="timer-display" class="timer text-violet-400 mb-6">00:00</div>
                            <p class="font-medium mb-2">Participants</p>
                            <div class="flex flex-wrap justify-center gap-2">${playersHTML}</div>
                        </div>
                    </div>
                `;
            }

            function getQuestionTimeHTML(room) {
                const questionerId = room.questionerOrder[room.currentQuestionerIndex];
                const questioner = room.players[questionerId];
                const isMyTurn = questionerId === localState.userId;

                return `
                    <div class="screen">
                        <div class="card text-center">
                            <h2 class="text-3xl font-bold mb-4">Question Time</h2>
                            <p class="text-gray-400 mb-6">It's <span class="font-bold text-violet-400">${questioner.name}'s</span> turn to ask a question.</p>
                            ${isMyTurn ? `
                                <p class="mb-4">Ask one person a question, or skip your turn.</p>
                                <div class="flex gap-4">
                                    <button id="next-questioner-btn" class="btn btn-primary w-full">Next Questioner</button>
                                    <button id="skip-question-btn" class="btn btn-secondary w-full">Skip</button>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }

            function getVotingHTML(room) {
                const me = room.players[localState.userId];
                if (me.isEliminated || me.hasVoted) {
                    return `
                        <div class="screen">
                            <div class="card text-center"><p class="text-xl">Waiting for others to vote...</p></div>
                        </div>`;
                }
                const voteButtonsHTML = Object.values(room.players)
                    .filter(p => !p.isEliminated)
                    .map(p => `<button class="btn btn-secondary w-full" data-vote-id="${p.id}" ${p.id === localState.userId ? 'disabled' : ''}>${p.name}</button>`)
                    .join('');
                return `
                    <div class="screen">
                        <div class="card text-center">
                            <h2 class="text-3xl font-bold mb-4">Vote Time (Round ${room.currentTurn})</h2>
                            <p class="text-gray-400 mb-6">Who do you think is the Wolf?</p>
                            <div class="grid grid-cols-2 sm:grid-cols-3 gap-3">${voteButtonsHTML}</div>
                        </div>
                    </div>
                `;
            }

            function getResultsHTML(room) {
                const eliminatedPlayer = Object.values(room.players).find(p => p.id === room.lastEliminatedId);
                let resultText = "The vote was a tie. No one was eliminated.";
                let roleRevealHTML = '';
                if (eliminatedPlayer) {
                    resultText = `${eliminatedPlayer.name} has been voted out.`;
                    const roleColor = eliminatedPlayer.role === 'wolf' ? 'text-red-500' : 'text-blue-500';
                    roleRevealHTML = `<p class="text-xl">${eliminatedPlayer.name} was a <span class="font-bold ${roleColor}">${eliminatedPlayer.role}</span>.</p>`;
                }
                const isHost = room.hostId === localState.userId;
                return `
                    <div class="screen">
                        <div class="card text-center">
                            <h2 class="text-3xl font-bold mb-4">Vote Results</h2>
                            <p class="text-xl mb-6">${resultText}</p>
                            ${roleRevealHTML}
                            ${isHost ? '<button id="next-round-btn" class="btn btn-primary w-full mt-6">Continue</button>' : '<p class="text-gray-400 mt-6">Waiting for the host to continue...</p>'}
                        </div>
                    </div>
                `;
            }
            
            function getEndGameHTML(room) {
                return `
                    <div class="screen">
                        <div class="card text-center">
                            <h2 class="text-4xl font-bold ${room.winner === 'citizens' ? 'text-blue-500' : 'text-red-500'}">${room.winner.charAt(0).toUpperCase() + room.winner.slice(1)} Win!</h2>
                            <p class="my-6">The words were:</p>
                            <div class="text-lg bg-gray-900 p-4 rounded-lg">
                                <p>Citizen: <span class="font-bold">${room.words.citizen}</span></p>
                                <p>Wolf: <span class="font-bold">${room.words.wolf}</span></p>
                            </div>
                            ${room.hostId === localState.userId ? '<button id="play-again-btn" class="btn btn-primary w-full mt-6">Play Again</button>' : '<p class="text-gray-400 mt-6">Waiting for the host...</p>'}
                        </div>
                    </div>
                `;
            }
            
            // --- Game Logic ---
            
            async function startGame(room) {
                const roomRef = doc(db, "rooms", room.id);
                const players = room.players;
                const settings = room.settings;
                const playerIds = Object.keys(players);
                const wolfCount = Math.max(1, Math.min(settings.wolfCount, playerIds.length - 1));

                if (playerIds.length < 3) {
                    alert("You need at least 3 players to start.");
                    return;
                }

                let roles = Array(playerIds.length).fill('citizen');
                for(let i = 0; i < wolfCount; i++) roles[i] = 'wolf';
                roles.sort(() => Math.random() - 0.5);

                let wordPair;
                if (settings.topic === 'custom') {
                    const customPairs = [];
                    document.querySelectorAll('.custom-pair').forEach(pairEl => {
                        const citizenWord = pairEl.querySelector('.citizen-word').value.trim();
                        const wolfWord = pairEl.querySelector('.wolf-word').value.trim();
                        if (citizenWord && wolfWord) {
                            customPairs.push([citizenWord, wolfWord]);
                        }
                    });

                    if (customPairs.length === 0) {
                        alert("Please add at least one valid custom word pair.");
                        return;
                    }
                    wordPair = customPairs[Math.floor(Math.random() * customPairs.length)];
                } else {
                    const topicData = settings.language === 'ja' ? TOPICS_JA : TOPICS_EN;
                    wordPair = topicData[settings.topic][Math.floor(Math.random() * topicData[settings.topic].length)];
                }
                
                const [wordA, wordB] = wordPair.sort(() => Math.random() - 0.5);
                
                const updatedPlayers = { ...players };
                playerIds.forEach((id, index) => {
                    updatedPlayers[id].role = roles[index];
                    updatedPlayers[id].word = roles[index] === 'wolf' ? wordB : wordA;
                });
                
                const questionerOrder = [...playerIds].sort(() => Math.random() - 0.5);

                await updateDoc(roomRef, {
                    gameState: 'role_assignment',
                    players: updatedPlayers,
                    words: { citizen: wordA, wolf: wordB },
                    currentTurn: 1,
                    questionerOrder: questionerOrder,
                    currentQuestionerIndex: 0,
                });
            }

            function handleTimer(room) {
                if (localState.timerInterval) clearInterval(localState.timerInterval);
                const timerDisplay = document.getElementById('timer-display');
                if (!timerDisplay) return;

                const nextState = room.gameState === 'talk_time' ? 'question_time' : 'voting';

                localState.timerInterval = setInterval(async () => {
                    const serverTime = room.phaseEndTime.toMillis();
                    const remaining = Math.max(0, Math.round((serverTime - Date.now()) / 1000));
                    const minutes = String(Math.floor(remaining / 60)).padStart(2, '0');
                    const seconds = String(remaining % 60).padStart(2, '0');
                    timerDisplay.textContent = `${minutes}:${seconds}`;

                    if (remaining <= 0 && localState.isHost) {
                        clearInterval(localState.timerInterval);
                        const roomRef = doc(db, "rooms", room.id);
                        await updateDoc(roomRef, { gameState: nextState });
                    }
                }, 500);
            }

            // --- Main Listener ---
            
            function attachRoomListener(roomId) {
                if (localState.roomUnsubscribe) localState.roomUnsubscribe();
                localState.roomUnsubscribe = onSnapshot(doc(db, "rooms", roomId), (doc) => {
                    const roomData = doc.data();
                    if (!roomData) {
                        if(localState.roomUnsubscribe) localState.roomUnsubscribe();
                        alert("The host has closed the room.");
                        window.location.href = '/';
                        return;
                    }
                    
                    localState.isHost = roomData.hostId === localState.userId;
                    if(localState.timerInterval && roomData.gameState !== 'talk_time' && roomData.gameState !== 'final_talk_time') {
                        clearInterval(localState.timerInterval);
                    }

                    switch (roomData.gameState) {
                        case 'waiting':
                            render(getWaitingRoomHTML(roomData));
                            addWaitingRoomListeners(roomData);
                            break;
                        case 'role_assignment':
                            const me = roomData.players[localState.userId];
                            if (me.acknowledged) {
                                render(`<div class="screen"><div class="card text-center"><p class="text-xl">Waiting for others to confirm...</p></div></div>`);
                            } else {
                                render(getRoleAssignmentHTML(roomData));
                                addRoleAssignmentListeners(roomData);
                            }
                            break;
                        case 'talk_time':
                        case 'final_talk_time':
                            render(getTalkTimeHTML(roomData));
                            handleTimer(roomData);
                            break;
                        case 'question_time':
                            render(getQuestionTimeHTML(roomData));
                            addQuestionTimeListeners(roomData);
                            break;
                        case 'voting':
                            render(getVotingHTML(roomData));
                            addVotingListeners(roomData);
                            break;
                        case 'results':
                            render(getResultsHTML(roomData));
                            addResultsListeners(roomData);
                            break;
                        case 'end_game':
                            render(getEndGameHTML(roomData));
                            addEndGameListeners(roomData);
                            break;
                    }
                });
            }
            
            // --- Event Listeners ---
            function addHomeListeners() {
                document.getElementById('create-room-btn').addEventListener('click', createRoom);
                document.getElementById('join-room-btn').addEventListener('click', () => joinRoom(null));
                document.getElementById('show-rules-btn').addEventListener('click', () => {
                    render(getRulesAndCreditsHTML());
                    document.getElementById('back-to-home-btn').addEventListener('click', () => {
                        render(getHomeScreenHTML());
                        addHomeListeners();
                    });
                });
            }

            function addWaitingRoomListeners(room) {
                if (localState.isHost) {
                    document.getElementById('start-game-btn').addEventListener('click', () => startGame(room));
                    
                    const updateSettings = async () => {
                        const roomRef = doc(db, "rooms", room.id);
                        await updateDoc(roomRef, {
                            "settings.wolfCount": parseInt(document.getElementById('wolf-count').value) || 1,
                            "settings.turnCount": parseInt(document.getElementById('turn-count').value) || 3,
                            "settings.talkTime": parseInt(document.getElementById('talk-time').value) || 180,
                            "settings.finalTalkTime": parseInt(document.getElementById('final-talk-time').value) || 60,
                            "settings.topic": document.getElementById('topic').value,
                            "settings.language": document.getElementById('language').value,
                        });
                    };
                    
                    ['language', 'wolf-count', 'turn-count', 'talk-time', 'final-talk-time'].forEach(id => {
                        document.getElementById(id).addEventListener('change', updateSettings);
                    });
                    
                    document.getElementById('topic').addEventListener('change', () => {
                        document.getElementById('custom-topic-area').classList.toggle('hidden', document.getElementById('topic').value !== 'custom');
                        updateSettings();
                    });

                    document.getElementById('add-pair-btn').addEventListener('click', () => {
                        const container = document.getElementById('custom-pairs-container');
                        const pairDiv = document.createElement('div');
                        pairDiv.className = 'custom-pair flex items-center gap-2 mt-2';
                        pairDiv.innerHTML = `
                            <input type="text" class="form-input citizen-word" placeholder="Citizen Word">
                            <input type="text" class="form-input wolf-word" placeholder="Wolf Word">
                            <button class="btn btn-secondary p-2 remove-pair-btn">X</button>
                        `;
                        container.appendChild(pairDiv);
                        pairDiv.querySelector('.remove-pair-btn').addEventListener('click', () => pairDiv.remove());
                    });
                    // Add one pair initially
                    if (document.querySelectorAll('.custom-pair').length === 0) {
                         document.getElementById('add-pair-btn').click();
                    }
                }
                document.getElementById('room-id-display').addEventListener('click', (e) => {
                    navigator.clipboard.writeText(room.id);
                    document.getElementById('copy-feedback').textContent = 'Copied!';
                    setTimeout(() => { 
                        if(document.getElementById('copy-feedback')) document.getElementById('copy-feedback').textContent = '' 
                    }, 2000);
                });
            }
            
            async function handleAcknowledgement(room) {
                const roomRef = doc(db, "rooms", room.id);
                await updateDoc(roomRef, { [`players.${localState.userId}.acknowledged`]: true });

                const updatedRoomSnap = await getDoc(roomRef);
                const updatedRoom = updatedRoomSnap.data();

                const allAckd = Object.values(updatedRoom.players).every(p => p.acknowledged);
                if (allAckd) {
                    const talkTimeInSeconds = updatedRoom.settings.talkTime || 180;
                    const phaseEndTime = new Date(Date.now() + talkTimeInSeconds * 1000);
                    await updateDoc(roomRef, { 
                        gameState: 'talk_time',
                        phaseEndTime: phaseEndTime
                    });
                }
            }

            function addRoleAssignmentListeners(room) {
                document.getElementById('ack-word-btn').addEventListener('click', () => handleAcknowledgement(room));
            }

            async function handleQuestionTurn(room) {
                const roomRef = doc(db, "rooms", room.id);
                const nextIndex = room.currentQuestionerIndex + 1;
                
                if (nextIndex >= room.questionerOrder.length) {
                    const finalTalkTimeInSeconds = room.settings.finalTalkTime || 60;
                    const phaseEndTime = new Date(Date.now() + finalTalkTimeInSeconds * 1000);
                    await updateDoc(roomRef, { gameState: 'final_talk_time', phaseEndTime: phaseEndTime });
                } else {
                    await updateDoc(roomRef, { currentQuestionerIndex: nextIndex });
                }
            }

            function addQuestionTimeListeners(room) {
                const isMyTurn = room.questionerOrder[room.currentQuestionerIndex] === localState.userId;
                if (isMyTurn) {
                    document.getElementById('next-questioner-btn').addEventListener('click', () => handleQuestionTurn(room));
                    document.getElementById('skip-question-btn').addEventListener('click', () => handleQuestionTurn(room));
                }
            }

            async function handleVote(votedId, room) {
                const roomRef = doc(db, "rooms", room.id);
                const currentVotes = room.players[votedId].votes || 0;
                await updateDoc(roomRef, {
                    [`players.${localState.userId}.hasVoted`]: true,
                    [`players.${votedId}.votes`]: currentVotes + 1
                });

                const updatedRoomSnap = await getDoc(roomRef);
                const updatedRoom = updatedRoomSnap.data();

                const allVoted = Object.values(updatedRoom.players).filter(p => !p.isEliminated).every(p => p.hasVoted);
                if (allVoted) {
                    tallyVotesAndProceed(updatedRoom);
                }
            }

            function addVotingListeners(room) {
                document.querySelectorAll('[data-vote-id]').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const votedId = e.currentTarget.dataset.voteId;
                        handleVote(votedId, room);
                    });
                });
            }

            async function tallyVotesAndProceed(room) {
                const roomRef = doc(db, "rooms", room.id);
                let maxVotes = -1;
                let mostVotedIds = [];
                Object.values(room.players).filter(p => !p.isEliminated).forEach(p => {
                    const pVotes = p.votes || 0;
                    if (pVotes > maxVotes) {
                        maxVotes = pVotes;
                        mostVotedIds = [p.id];
                    } else if (pVotes === maxVotes) {
                        mostVotedIds.push(p.id);
                    }
                });
                
                let lastEliminatedId = null;
                if (mostVotedIds.length === 1 && maxVotes > 0) {
                    lastEliminatedId = mostVotedIds[0];
                }

                const updatePayload = { gameState: 'results', lastEliminatedId };
                if(lastEliminatedId) {
                    updatePayload[`players.${lastEliminatedId}.isEliminated`] = true;
                }
                
                Object.keys(room.players).forEach(id => {
                    updatePayload[`players.${id}.votes`] = 0;
                    updatePayload[`players.${id}.hasVoted`] = false;
                });

                await updateDoc(roomRef, updatePayload);
            }

            function addResultsListeners(room) {
                if (!localState.isHost) return;
                document.getElementById('next-round-btn').addEventListener('click', async () => {
                    const roomRef = doc(db, "rooms", room.id);
                    
                    const remainingPlayers = Object.values(room.players).filter(p => !p.isEliminated);
                    const remainingWolves = remainingPlayers.filter(p => p.role === 'wolf').length;
                    const remainingCitizens = remainingPlayers.length - remainingWolves;
                    const currentTurn = room.currentTurn || 1;
                    const maxTurns = room.settings.turnCount || 3;

                    if (remainingWolves === 0) {
                        await updateDoc(roomRef, { gameState: 'end_game', winner: 'citizens' });
                    } else if (remainingWolves >= remainingCitizens) {
                        await updateDoc(roomRef, { gameState: 'end_game', winner: 'wolves' });
                    } else if (currentTurn >= maxTurns) {
                        await updateDoc(roomRef, { gameState: 'end_game', winner: 'wolves' });
                    } else {
                        const talkTimeInSeconds = room.settings.talkTime || 180;
                        const phaseEndTime = new Date(Date.now() + talkTimeInSeconds * 1000);
                        const newQuestionerOrder = remainingPlayers.map(p => p.id).sort(() => Math.random() - 0.5);
                        await updateDoc(roomRef, { 
                            gameState: 'talk_time',
                            phaseEndTime: phaseEndTime,
                            lastEliminatedId: null,
                            currentTurn: currentTurn + 1,
                            questionerOrder: newQuestionerOrder,
                            currentQuestionerIndex: 0
                        });
                    }
                });
            }

            function addEndGameListeners(room) {
                if (!localState.isHost) return;
                document.getElementById('play-again-btn').addEventListener('click', async () => {
                    const roomRef = doc(db, "rooms", room.id);
                    const playersReset = { ...room.players };
                    Object.keys(playersReset).forEach(id => {
                        delete playersReset[id].role;
                        delete playersReset[id].word;
                        delete playersReset[id].acknowledged;
                        delete playersReset[id].isEliminated;
                        delete playersReset[id].hasVoted;
                        delete playersReset[id].votes;
                    });
                    await updateDoc(roomRef, {
                        gameState: 'waiting',
                        players: playersReset,
                        lastEliminatedId: null,
                        winner: null,
                        words: null,
                        currentTurn: null,
                        questionerOrder: null,
                        currentQuestionerIndex: null,
                    });
                });
            }

            // --- Initial Load ---
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    localState.userId = user.uid;
                    const pathRoomId = window.location.pathname.split('/room/')[1];
                    if(pathRoomId) {
                        joinRoom(pathRoomId.toUpperCase());
                    } else {
                        render(getHomeScreenHTML());
                        addHomeListeners();
                    }
                } else {
                    signInAnonymously(auth);
                }
            });

            // --- Helper Functions ---
            async function createRoom() {
                if (!validatePlayerName()) return;
                localState.isHost = true;
                const roomId = Math.random().toString(36).substring(2, 8).toUpperCase();
                window.history.pushState({}, '', `/room/${roomId}`);
                const roomRef = doc(db, "rooms", roomId);
                const newPlayer = {
                    [localState.userId]: { name: localState.playerName, isHost: true }
                };
                await setDoc(roomRef, {
                    id: roomId,
                    hostId: localState.userId,
                    gameState: 'waiting',
                    players: newPlayer,
                    settings: { wolfCount: 1, topic: 'food', language: 'en', turnCount: 3, talkTime: 180, finalTalkTime: 60 }
                });
                attachRoomListener(roomId);
            }

            async function joinRoom(roomId) {
                if (!roomId) {
                    const joinId = document.getElementById('join-room-id-input').value.trim().toUpperCase();
                     if(!joinId) { alert('Please enter a Room ID.'); return; }
                     roomId = joinId;
                }
                if (!validatePlayerName()) return;
                
                const roomRef = doc(db, "rooms", roomId);
                const roomSnap = await getDoc(roomRef);

                if (!roomSnap.exists()) {
                    alert("Room not found!");
                    return;
                }
                
                window.history.pushState({}, '', `/room/${roomId}`);
                const newPlayerData = { name: localState.playerName, isHost: roomSnap.data().hostId === localState.userId };
                await updateDoc(roomRef, { [`players.${localState.userId}`]: newPlayerData });

                attachRoomListener(roomId);
            }

            function validatePlayerName() {
                const nameInput = document.getElementById('player-name-input');
                if(!nameInput) return true; // Already in a room
                const playerName = nameInput.value.trim();
                if (!playerName) {
                    alert('Please enter your name.');
                    return false;
                }
                localState.playerName = playerName;
                localStorage.setItem('playerName', playerName);
                return true;
            }
        } catch (error) {
            appContainer.innerHTML = `
                <div class="screen">
                    <div class="card text-center">
                        <h1 class="text-2xl font-bold text-red-500">An Error Occurred</h1>
                        <p class="text-gray-400 mt-4">Could not load the game. Please check the Firebase configuration in the code and try again.</p>
                        <p class="text-xs text-gray-500 mt-2">${error.message}</p>
                    </div>
                </div>
            `;
            console.error("Initialization Error:", error);
        }
    </script>
</body>
</html>

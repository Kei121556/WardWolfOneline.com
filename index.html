<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Wolf Game</title>
    <meta name="description" content="Word Wolf is a real-time multiplayer word guessing game. Find the player who has a slightly different word from everyone else!">
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Noto+Sans+JP:wght@400;500;700&display=swap"></noscript>
    
    <style>
        :root {
            --primary-color: #7c3aed; /* Violet */
            --danger-color: #dc2626; /* Red */
            --background-color: #111827; /* Gray 900 */
            --card-bg: #1f2937; /* Gray 800 */
            --text-color: #f9fafb; /* Gray 50 */
            --border-color: #374151; /* Gray 700 */
            --link-color: #a78bfa; 
        }
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            overscroll-behavior: none;
        }
        .screen {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 1rem;
            box-sizing: border-box;
            transition: opacity 0.5s ease-in-out;
        }
        .card {
            background-color: var(--card-bg);
            border-radius: 1rem;
            padding: 2rem;
            width: 100%;
            max-width: 500px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--border-color);
        }
        .btn {
            display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem;
            padding: 0.75rem 1.5rem; border-radius: 0.5rem; font-weight: 600;
            text-align: center; cursor: pointer; transition: all 0.2s ease-in-out; border: none;
        }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background-color: var(--primary-color); color: white; }
        .btn-primary:hover:not(:disabled) { background-color: #6d28d9; }
        .btn-secondary { background-color: #374151; color: white; }
        .btn-secondary:hover:not(:disabled) { background-color: #4b5563; }
        .form-input, .form-select, .form-textarea {
            width: 100%; padding: 0.5rem 0.75rem; border-radius: 0.5rem;
            background-color: #374151; border: 1px solid #4b5563; color: white; margin-top: 0.25rem;
        }
        .timer { font-size: 4rem; font-weight: 700; line-height: 1; font-variant-numeric: tabular-nums; }
        @media (min-width: 640px) { .timer { font-size: 6rem; } }
        .rules-list { list-style-position: inside; text-align: left; }
        .rules-list li { margin-bottom: 0.5rem; }
        
        .modal-container {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0,0,0,0.5); display: flex;
            justify-content: center; align-items: center; z-index: 1000;
            opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
        }
        .modal-container.visible { opacity: 1; pointer-events: auto; }
        .modal-box {
            background-color: var(--card-bg); border: 1px solid var(--border-color);
            border-radius: 1rem; padding: 2rem; width: 90%; max-width: 400px;
            text-align: center; transform: scale(0.95); transition: transform 0.3s ease;
        }
        .modal-container.visible .modal-box { transform: scale(1); }
        .modal-text { margin-bottom: 1.5rem; font-size: 1.125rem; line-height: 1.75rem; }
        .loader {
            border: 4px solid #f3f3f3; border-radius: 50%;
            border-top: 4px solid var(--primary-color);
            width: 40px; height: 40px;
            animation: spin 1s linear infinite;
            margin: 1rem auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="app-container">
        <div class="screen">
            <div class="card text-center">
                <p id="loading-text" class="text-2xl">Loading Game...</p>
                 <div class="loader mt-4"></div>
            </div>
        </div>
    </div>

    <div id="message-box-container" class="modal-container">
        <div class="modal-box">
            <p id="message-box-text" class="modal-text"></p>
            <button id="message-box-close" class="btn btn-primary w-full">OK</button>
        </div>
    </div>
    <div id="rejoin-prompt-container" class="modal-container">
        <div class="modal-box">
            <p id="rejoin-prompt-text" class="modal-text"></p>
            <div class="flex gap-4">
                <button id="rejoin-cancel-btn" class="btn btn-secondary w-full">Cancel</button>
                <button id="rejoin-confirm-btn" class="btn btn-primary w-full">Rejoin</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot, runTransaction, collection, getDocs, writeBatch, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

        const TOPICS_EN = { 
            food: [["Curry", "Stew"], ["Udon", "Soba"], ["Beer", "Low-malt Beer"], ["Apple", "Pear"], ["Macaron", "Fatcaron"], ["Sushi", "Sashimi"], ["Coffee", "Tea"], ["Steak", "Hamburger"], ["Pasta", "Pizza"], ["Pancake", "Waffle"], ["Chocolate", "Caramel"], ["Cheese", "Butter"]], 
            places: [["Tokyo Tower", "Skytree"], ["Disneyland", "DisneySea"], ["Kinkaku-ji", "Ginkaku-ji"], ["Ocean", "River"], ["Convenience Store", "Supermarket"], ["Mountain", "Volcano"], ["School", "Hospital"], ["Museum", "Art Gallery"], ["Airport", "Train Station"], ["Park", "Garden"], ["Library", "Bookstore"], ["Cafe", "Restaurant"]], 
            people: [["Actor", "Voice Actor"], ["Santa Claus", "Reindeer"], ["Teacher", "Student"], ["King", "President"], ["Scientist", "Inventor"], ["Artist", "Musician"], ["Chef", "Pâtissier"], ["Athlete", "Coach"], ["Detective", "Police Officer"], ["YouTuber", "Streamer"], ["Pilot", "Astronaut"], ["Farmer", "Gardener"]], 
            actions: [["Running", "Jogging"], ["Cooking", "Eating"], ["Sleeping", "Napping"], ["Studying", "Working"], ["Clapping", "Hand clapping"], ["Singing", "Dancing"], ["Reading", "Writing"], ["Drawing", "Painting"], ["Laughing", "Crying"], ["Walking", "Hiking"], ["Push", "Pull"], ["Throw", "Catch"]], 
            things: [["Smartphone", "Cellphone"], ["Shampoo", "Conditioner"], ["PC", "Laptop"], ["Pencil", "Mechanical Pencil"], ["Umbrella", "Parasol"], ["Chair", "Sofa"], ["Book", "Magazine"], ["Key", "Lock"], ["Watch", "Clock"], ["Glasses", "Sunglasses"], ["Spoon", "Fork"], ["Towel", "Blanket"]], 
            sports: [["Soccer", "Futsal"], ["Baseball", "Softball"], ["Tennis", "Badminton"], ["Table Tennis", "Ping-Pong"], ["Swimming", "Diving"], ["Skiing", "Snowboarding"], ["Basketball", "Volleyball"], ["Judo", "Karate"], ["Golf", "Bowling"], ["Boxing", "Wrestling"], ["Skateboarding", "Surfing"], ["Archery", "Darts"]], 
            entertainment: [["Movie", "Drama"], ["Manga", "Anime"], ["Theater", "Musical"], ["YouTube", "TikTok"], ["Concert", "Festival"], ["Comedy", "Tragedy"], ["Radio", "Podcast"], ["Circus", "Magic Show"], ["Ballet", "Opera"], ["Video Game", "Arcade Game"], ["Novel", "Poem"], ["Sculpture", "Painting"]], 
            animals: [["Dog", "Cat"], ["Lion", "Tiger"], ["Dolphin", "Whale"], ["Hamster", "Guinea Pig"], ["Horse", "Zebra"], ["Chicken", "Duck"], ["Snake", "Lizard"], ["Butterfly", "Moth"], ["Spider", "Scorpion"], ["Rabbit", "Hare"], ["Penguin", "Ostrich"], ["Frog", "Toad"]], 
            nature: [["Sun", "Moon"], ["Mountain", "Hill"], ["Spring", "Autumn"], ["Thunder", "Lightning"], ["Cloud", "Fog"], ["Rain", "Snow"], ["Wind", "Breeze"], ["Star", "Planet"], ["Forest", "Jungle"], ["Desert", "Oasis"], ["River", "Lake"], ["Volcano", "Geyser"]], 
            tech: [["AI", "Robot"], ["Internet", "Intranet"], ["VR", "AR"], ["Programming", "Coding"], ["Drone", "Helicopter"], ["Email", "Letter"], ["Headphones", "Earphones"], ["Camera", "Video Camera"], ["Printer", "Scanner"], ["Tablet", "e-Reader"], ["Mouse", "Keyboard"], ["Battery", "Charger"]], 
            fantasy: [["Wizard", "Witch"], ["Dragon", "Wyvern"], ["Elf", "Dwarf"], ["Hero", "Demon Lord"], ["Ghost", "Zombie"], ["Angel", "Demon"], ["Unicorn", "Pegasus"], ["Vampire", "Werewolf"], ["Mermaid", "Siren"], ["Fairy", "Goblin"], ["Phoenix", "Griffin"], ["Potion", "Spell"]], 
            games: [["Mario", "Luigi"], ["Final Fantasy", "Dragon Quest"], ["Puzzle", "Quiz"], ["Board Game", "Card Game"], ["Pokémon", "Digimon"], ["Minecraft", "Roblox"], ["Chess", "Shogi"], ["Tag", "Hide-and-seek"], ["Poker", "Blackjack"], ["Billiards", "Darts"], ["Monopoly", "Scrabble"], ["Tetris", "Pac-Man"]], 
            history: [["Rome", "Greece"], ["Knight", "Samurai"], ["Pyramid", "Sphinx"], ["World War I", "World War II"], ["Renaissance", "Industrial Revolution"], ["Castle", "Fortress"], ["Viking", "Pirate"], ["Dinosaur", "Mammoth"], ["King", "Emperor"], ["Revolution", "Rebellion"], ["Napoleon", "Caesar"], ["Cleopatra", "Joan of Arc"]], 
            jobs: [["Doctor", "Nurse"], ["Police Officer", "Firefighter"], ["Baker", "Pâtissier"], ["Pilot", "Cabin Attendant"], ["Lawyer", "Prosecutor"], ["Writer", "Journalist"], ["Designer", "Architect"], ["Farmer", "Fisherman"], ["Singer", "Dancer"], ["Engineer", "Mechanic"], ["Photographer", "Videographer"], ["Librarian", "Curator"]], 
            colors: [["Red", "Pink"], ["Black", "Navy"], ["Gold", "Silver"], ["Orange", "Brown"], ["Green", "Lime"], ["Blue", "Sky Blue"], ["Purple", "Lavender"], ["White", "Ivory"], ["Gray", "Charcoal"], ["Beige", "Cream"], ["Turquoise", "Teal"], ["Magenta", "Fuchsia"]],
            uk_landmarks: [["Big Ben", "Tower of London"], ["Buckingham Palace", "Windsor Castle"], ["Stonehenge", "Hadrian's Wall"], ["The British Museum", "The National Gallery"], ["Tower Bridge", "London Bridge"], ["Edinburgh Castle", "Cardiff Castle"], ["London Eye", "The Shard"], ["Oxford University", "Cambridge University"], ["Borough Market", "Harrods"], ["The Cotswolds", "Lake District"], ["Giant's Causeway", "White Cliffs of Dover"]],
            uk_food: [["Fish and Chips", "Shepherd's Pie"], ["Tea", "Afternoon Tea"], ["Scone", "Crumpet"], ["Gin", "Whisky"], ["Cheddar cheese", "Stilton cheese"], ["Jaffa Cakes", "Digestive Biscuits"], ["Haggis", "Black Pudding"], ["Cornish Pasty", "Sausage Roll"], ["Earl Grey", "English Breakfast"], ["Eton Mess", "Trifle"]],
            uk_culture: [["The Beatles", "The Rolling Stones"], ["Queen", "Oasis"], ["Sherlock Holmes", "James Bond"], ["Harry Potter", "The Lord of the Rings"], ["King Arthur", "Robin Hood"], ["Shakespeare", "Charles Dickens"], ["Paddington Bear", "Winnie-the-Pooh"], ["Guy Fawkes Night", "Halloween"], ["Afternoon Tea", "High Tea"], ["Pantomime", "Shakespearean Theatre"]],
            uk_sports_politics: [["Football", "Rugby"], ["Wimbledon", "The Open Championship"], ["House of Commons", "House of Lords"], ["Prince", "Princess"], ["Cricket", "Croquet"], ["MI6", "Scotland Yard"]],
            uk_symbols: [["Double-decker bus", "Black cab"], ["Red telephone box", "Red post box"], ["Union Jack", "Flag of England"], ["The Crown", "Sceptre"], ["Rose", "Thistle"], ["Lion", "Unicorn"]],
            uk_geography: [["England", "Scotland"], ["London", "Manchester"], ["Isle of Wight", "Isle of Man"], ["River Thames", "River Severn"], ["The Pennines", "The Highlands"], ["Cambridge", "Oxford"]]
        };
        const TOPIC_NAMES_EN = { food: "Food & Drink", places: "Places", people: "People", actions: "Actions", things: "Things", sports: "Sports", entertainment: "Entertainment", animals: "Animals", nature: "Nature", tech: "Technology", fantasy: "Fantasy", games: "Games", history: "History", jobs: "Jobs", colors: "Colors", uk_landmarks: "UK: Landmarks", uk_food: "UK: Food & Drink", uk_culture: "UK: Culture", uk_sports_politics: "UK: Sports & Politics", uk_symbols: "UK: Symbols", uk_geography: "UK: Geography" };
        
        // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        // ★★★              日本語単語追加 修正箇所             ★★★
        // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        const TOPICS_JA = {
            food: [["カレー", "シチュー"], ["うどん", "そば"], ["ビール", "発泡酒"], ["りんご", "なし"], ["マカロン", "トゥンカロン"], ["寿司", "刺身"], ["コーヒー", "紅茶"], ["ステーキ", "ハンバーグ"], ["パスタ", "ピザ"], ["パンケーキ", "ワッフル"], ["チョコレート", "キャラメル"], ["チーズ", "バター"]],
            places: [["東京タワー", "スカイツリー"], ["ディズニーランド", "ディズニーシー"], ["金閣寺", "銀閣寺"], ["海", "川"], ["コンビニ", "スーパー"], ["山", "火山"], ["学校", "病院"], ["博物館", "美術館"], ["空港", "駅"], ["公園", "庭園"], ["図書館", "本屋"], ["カフェ", "レストラン"]],
            people: [["俳優", "声優"], ["サンタクロース", "トナカイ"], ["先生", "生徒"], ["王様", "大統領"], ["科学者", "発明家"], ["芸術家", "音楽家"], ["シェフ", "パティシエ"], ["スポーツ選手", "コーチ"], ["探偵", "警察官"], ["YouTuber", "配信者"], ["パイロット", "宇宙飛行士"], ["農家", "庭師"]],
            actions: [["走る", "ジョギング"], ["料理する", "食べる"], ["寝る", "昼寝"], ["勉強する", "仕事する"], ["拍手", "手拍子"], ["歌う", "踊る"], ["読む", "書く"], ["描く", "塗る"], ["笑う", "泣く"], ["歩く", "ハイキング"], ["押す", "引く"], ["投げる", "キャッチする"]],
            things: [["スマホ", "携帯電話"], ["シャンプー", "リンス"], ["パソコン", "ノートパソコン"], ["鉛筆", "シャーペン"], ["傘", "日傘"], ["椅子", "ソファ"], ["本", "雑誌"], ["鍵", "錠"], ["腕時計", "時計"], ["メガネ", "サングラス"], ["スプーン", "フォーク"], ["タオル", "毛布"]],
            sports: [["サッカー", "フットサル"], ["野球", "ソフトボール"], ["テニス", "バドミントン"], ["卓球", "ピンポン"], ["水泳", "飛び込み"], ["スキー", "スノーボード"], ["バスケットボール", "バレーボール"], ["柔道", "空手"], ["ゴルフ", "ボウリング"], ["ボクシング", "レスリング"], ["スケートボード", "サーフィン"], ["弓道", "ダーツ"]],
            entertainment: [["映画", "ドラマ"], ["漫画", "アニメ"], ["演劇", "ミュージカル"], ["YouTube", "TikTok"], ["コンサート", "フェス"], ["喜劇", "悲劇"], ["ラジオ", "ポッドキャスト"], ["サーカス", "マジックショー"], ["バレエ", "オペラ"], ["テレビゲーム", "アーケードゲーム"], ["小説", "詩"], ["彫刻", "絵画"]],
            animals: [["犬", "猫"], ["ライオン", "トラ"], ["イルカ", "クジラ"], ["ハムスター", "モルモット"], ["馬", "シマウマ"], ["ニワトリ", "アヒル"], ["ヘビ", "トカゲ"], ["蝶", "蛾"], ["クモ", "サソリ"], ["うさぎ", "野うさぎ"], ["ペンギン", "ダチョウ"], ["カエル", "ヒキガエル"]],
            nature: [["太陽", "月"], ["山", "丘"], ["春", "秋"], ["雷", "稲妻"], ["雲", "霧"], ["雨", "雪"], ["風", "そよ風"], ["星", "惑星"], ["森", "ジャングル"], ["砂漠", "オアシス"], ["川", "湖"], ["火山", "間欠泉"]],
            tech: [["AI", "ロボット"], ["インターネット", "イントラネット"], ["VR", "AR"], ["プログラミング", "コーディング"], ["ドローン", "ヘリコプター"], ["メール", "手紙"], ["ヘッドホン", "イヤホン"], ["カメラ", "ビデオカメラ"], ["プリンター", "スキャナー"], ["タブレット", "電子書籍リーダー"], ["マウス", "キーボード"], ["電池", "充電器"]],
            fantasy: [["魔法使い", "魔女"], ["ドラゴン", "ワイバーン"], ["エルフ", "ドワーフ"], ["勇者", "魔王"], ["幽霊", "ゾンビ"], ["天使", "悪魔"], ["ユニコーン", "ペガサス"], ["吸血鬼", "狼男"], ["人魚", "セイレーン"], ["妖精", "ゴブリン"], ["フェニックス", "グリフィン"], ["ポーション", "呪文"]],
            games: [["マリオ", "ルイージ"], ["ファイナルファンタジー", "ドラゴンクエスト"], ["パズル", "クイズ"], ["ボードゲーム", "カードゲーム"], ["ポケモン", "デジモン"], ["マインクラフト", "ロブロックス"], ["チェス", "将棋"], ["鬼ごっこ", "かくれんぼ"], ["ポーカー", "ブラックジャック"], ["ビリヤード", "ダーツ"], ["モノポリー", "スクラブル"], ["テトリス", "パックマン"]],
            history: [["ローマ", "ギリシャ"], ["騎士", "侍"], ["ピラミッド", "スフィンクス"], ["第一次世界大戦", "第二次世界大戦"], ["ルネサンス", "産業革命"], ["城", "要塞"], ["バイキング", "海賊"], ["恐竜", "マンモス"], ["王", "皇帝"], ["革命", "反乱"], ["ナポレオン", "カエサル"], ["クレオパトラ", "ジャンヌ・ダルク"]],
            jobs: [["医者", "看護師"], ["警察官", "消防士"], ["パン職人", "パティシエ"], ["パイロット", "客室乗務員"], ["弁護士", "検察官"], ["作家", "ジャーナリスト"], ["デザイナー", "建築家"], ["農家", "漁師"], ["歌手", "ダンサー"], ["エンジニア", "整備士"], ["写真家", "ビデオグラファー"], ["司書", "学芸員"]],
            colors: [["赤", "ピンク"], ["黒", "紺"], ["金", "銀"], ["オレンジ", "茶色"], ["緑", "ライム"], ["青", "水色"], ["紫", "ラベンダー"], ["白", "アイボリー"], ["灰色", "チャコール"], ["ベージュ", "クリーム"], ["ターコイズ", "ティール"], ["マゼンタ", "フクシャ"]],
            uk_landmarks: [["ビッグベン", "ロンドン塔"], ["バッキンガム宮殿", "ウィンザー城"], ["ストーンヘンジ", "ハドリアヌスの長城"], ["大英博物館", "ナショナル・ギャラリー"], ["タワーブリッジ", "ロンドン橋"], ["エディンバラ城", "カーディフ城"], ["ロンドン・アイ", "ザ・シャード"], ["オックスフォード大学", "ケンブリッジ大学"], ["バラ・マーケット", "ハロッズ"], ["コッツウォルズ", "湖水地方"], ["ジャイアンツ・コーズウェー", "ドーバーの白い崖"]],
            uk_food: [["フィッシュ・アンド・チップス", "シェパーズパイ"], ["紅茶", "アフタヌーンティー"], ["スコーン", "クランペット"], ["ジン", "ウィスキー"], ["チェダーチーズ", "スティルトン"], ["ジャファケーキ", "ダイジェスティブビスケット"], ["ハギス", "ブラックプディング"], ["コーニッシュパスティ", "ソーセージロール"], ["アールグレイ", "イングリッシュブレックファスト"], ["イートン・メス", "トライフル"]],
            uk_culture: [["ビートルズ", "ローリング・ストーンズ"], ["クイーン", "オアシス"], ["シャーロック・ホームズ", "ジェームズ・ボンド"], ["ハリー・ポッター", "指輪物語"], ["アーサー王", "ロビン・フッド"], ["シェイクスピア", "チャールズ・ディケンズ"], ["パディントンベア", "くまのプーさん"], ["ガイ・フォークス・ナイト", "ハロウィーン"], ["アフタヌーンティー", "ハイティー"], ["パントマイム", "シェイクスピア劇"]],
            uk_sports_politics: [["サッカー", "ラグビー"], ["ウィンブルドン", "全英オープン"], ["庶民院", "貴族院"], ["王子", "王女"], ["クリケット", "クロッケー"], ["MI6", "スコットランドヤード"]],
            uk_symbols: [["2階建てバス", "ブラックキャブ"], ["赤い電話ボックス", "赤い郵便ポスト"], ["ユニオンジャック", "イングランドの旗"], ["王冠", "王笏"], ["バラ", "アザミ"], ["ライオン", "ユニコーン"]],
            uk_geography: [["イングランド", "スコットランド"], ["ロンドン", "マンチェスター"], ["ワイト島", "マン島"], ["テムズ川", "セヴァーン川"], ["ペナイン山脈", "ハイランド地方"], ["ケンブリッジ", "オックスフォード"]]
        };
        const TOPIC_NAMES_JA = { food: "食べ物・飲み物", places: "場所", people: "人物", actions: "行動", things: "モノ", sports: "スポーツ", entertainment: "エンタメ", animals: "動物", nature: "自然", tech: "テクノロジー", fantasy: "ファンタジー", games: "ゲーム", history: "歴史", jobs: "職業", colors: "色", uk_landmarks: "UK: 名所", uk_food: "UK: 食べ物", uk_culture: "UK: 文化", uk_sports_politics: "UK: スポーツ・政治", uk_symbols: "UK: シンボル", uk_geography: "UK: 地理" };

        class WordWolfGame {
            constructor() {
                this.db = null;
                this.auth = null;
                this.appContainer = document.getElementById('app-container');
                this.localState = {
                    userId: null,
                    playerName: localStorage.getItem('playerName') || '',
                    roomId: null,
                    isHost: false,
                    roomUnsubscribe: null,
                    timerInterval: null,
                    aiGeneratedPair: null,
                };
                
                this.initialize();
            }

            async initialize() {
                try {
                    let firebaseConfig;
                    if (typeof __firebase_config !== 'undefined' && __firebase_config) {
                        console.log("Using environment-provided Firebase config.");
                        firebaseConfig = JSON.parse(__firebase_config);
                    } else {
                        console.log("Using fallback Firebase configuration for Vercel/standalone deployment.");
                        firebaseConfig = {
                            apiKey: "AIzaSyDn4Opa-EY6Dm1ZZ1TAGAomTa2EJPjOXxQ",
                            authDomain: "wordwolfononline.firebaseapp.com",
                            projectId: "wordwolfononline",
                            storageBucket: "wordwolfononline.appspot.com",
                            messagingSenderId: "215407092675",
                            appId: "1:215407092675:web:a2d2f71de0c71430e71376",
                            measurementId: "G-BGJL4PKZ19"
                        };
                    }

                    if (!firebaseConfig || !firebaseConfig.apiKey) {
                         throw new Error("Firebase configuration is invalid or missing.");
                    }
                    
                    const app = initializeApp(firebaseConfig);
                    this.db = getFirestore(app);
                    this.auth = getAuth(app);

                    this.setupModalListeners();
                    this.setupAuthListener();

                } catch (error) {
                    console.error("Initialization Error:", error);
                    this.showMessage(`初期化エラー: ${error.message}`);
                }
            }
            
            setupAuthListener() {
                onAuthStateChanged(this.auth, async (user) => {
                    if (user) {
                        this.localState.userId = user.uid;
                        this.handleUserAuthenticated();
                    } else {
                        try {
                            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                                await signInWithCustomToken(this.auth, __initial_auth_token);
                            } else {
                                await signInAnonymously(this.auth);
                            }
                        } catch (error) {
                            console.error("Authentication failed:", error);
                            this.showMessage("認証に失敗しました。ページを再読み込みしてください。");
                        }
                    }
                });
            }

            handleUserAuthenticated() {
                const pathRoomId = window.location.pathname.split('/room/')[1];
                const savedRoomId = localStorage.getItem('wordWolfRoomId');

                if (pathRoomId) {
                    this.joinRoom(pathRoomId.toUpperCase());
                } else if (savedRoomId) {
                    this.showRejoinPrompt(savedRoomId,
                        () => this.joinRoom(savedRoomId),
                        () => {
                            localStorage.removeItem('wordWolfRoomId');
                            this.renderHomeScreen();
                        }
                    );
                } else {
                    this.renderHomeScreen();
                }
            }
            
            render(html) {
                this.appContainer.innerHTML = html;
            }

            renderHomeScreen() {
                this.render(this.getHomeScreenHTML());
                this.addHomeListeners();
                if (this.localState.userId) {
                    const userIdDisplay = document.getElementById('user-id-display');
                    if (userIdDisplay) userIdDisplay.textContent = this.localState.userId;
                }
            }
            
            getHomeScreenHTML() {
                return `
                    <div class="screen">
                        <div class="card text-center">
                            <h1 class="text-4xl font-bold text-violet-400">Word Wolf</h1>
                            <p class="text-gray-300 mt-2 mb-8">The Ultimate Word Finding Game</p>
                            <div class="space-y-4">
                                <input type="text" id="player-name-input" class="form-input text-center" placeholder="Enter your name" value="${this.localState.playerName}">
                                <button id="create-room-btn" class="btn btn-primary w-full">Create Room</button>
                                <div class="flex items-center gap-2">
                                    <input type="text" id="join-room-id-input" class="form-input text-center" placeholder="Room ID">
                                    <button id="join-room-btn" class="btn btn-secondary">Join</button>
                                </div>
                            </div>
                            <div class="mt-6 text-xs text-gray-500 text-left p-2 border border-gray-700 rounded-md">
                                <p class="font-bold mb-1">Your User ID:</p>
                                <p class="font-mono break-all" id="user-id-display">Loading...</p>
                            </div>
                            <button id="show-rules-btn" style="color: var(--link-color);" class="mt-8">How to Play & Credits</button>
                        </div>
                    </div>
                `;
            }

            getRulesAndCreditsHTML() {
               return `
                    <div class="screen">
                        <div class="card">
                            <div class="text-center mb-6"><h1 class="text-3xl font-bold">Word Wolf</h1></div>
                            <div class="space-y-6">
                                <div>
                                    <h2 class="text-xl font-bold mb-2 text-violet-400">What is Word Wolf?</h2>
                                    <p class="text-gray-300">It's a game to find the "wolf" who has been given a different word from everyone else (the "citizens"). Use discussion to find the person who doesn't quite fit in!</p>
                                </div>
                                <div>
                                    <h2 class="text-xl font-bold mb-2 text-violet-400">Game Flow</h2>
                                    <ol class="list-decimal rules-list space-y-2 text-gray-300">
                                        <li><b>Setup:</b> The host sets the game rules in the waiting room.</li>
                                        <li><b>Check Word:</b> Secretly check your assigned word. You won't be told your role!</li>
                                        <li><b>Talk Time:</b> Discuss the topic to find the wolf.</li>
                                        <li><b>Question Time:</b> One by one, ask another player a question that must be answered with "Yes" or "No".</li>
                                        <li><b>Final Talk Time:</b> One last chance to discuss before the vote.</li>
                                        <li><b>Vote:</b> Select a player and confirm your vote.</li>
                                        <li><b>Result:</b> See who was eliminated and if the game ends!</li>
                                    </ol>
                                </div>
                                <div>
                                    <h2 class="text-xl font-bold mb-2 text-violet-400">Credits</h2>
                                    <div class="text-gray-400 text-sm text-center space-y-1">
                                        <p>Creator: KY</p>
                                        <p>Special Thanks: Kei & Gemini</p>
                                    </div>
                                </div>
                                <button id="back-to-home-btn" class="btn btn-primary w-full mt-4">Back</button>
                            </div>
                        </div>
                    </div>
                `;
            }

            getWaitingRoomHTML(room) {
                const isHost = room.hostId === this.localState.userId;
                const sortedPlayers = Object.values(room.players).sort((a, b) => a.joinedAt - b.joinedAt);
                const playersHTML = sortedPlayers.map(p => `<span class="p-2 rounded-full bg-gray-700">${p.name} ${p.isHost ? '👑' : ''}</span>`).join('');
                const topicNames = room.settings.language === 'ja' ? TOPIC_NAMES_JA : TOPIC_NAMES_EN;
                const topicOptionsHTML = Object.keys(topicNames).map(key => `<option value="${key}">${topicNames[key]}</option>`).join('');

                return `
                    <div class="screen">
                        <div class="card text-center">
                            <p class="text-gray-300">Room ID</p>
                            <div class="bg-gray-900 p-3 rounded-md font-mono text-2xl tracking-widest my-2 cursor-pointer" id="room-id-display">${room.id}</div>
                            <p id="copy-feedback" class="text-sm text-green-400 h-4"></p>
                            <h2 class="text-xl font-bold mt-6 mb-3">Players (${Object.keys(room.players).length})</h2>
                            <div class="flex flex-wrap justify-center gap-2 mb-6">${playersHTML}</div>
                            ${isHost ? `
                                <div class="text-left space-y-4 mt-4 border-t border-gray-700 pt-4">
                                    <div>
                                        <label for="language" class="font-medium">Language</label>
                                        <select id="language" class="form-select">
                                            <option value="en" ${room.settings.language === 'en' ? 'selected' : ''}>English</option>
                                            <option value="ja" ${room.settings.language === 'ja' ? 'selected' : ''}>日本語</option>
                                        </select>
                                    </div>
                                    <div class="grid grid-cols-2 gap-4">
                                        <div><label for="wolf-count" class="font-medium">Wolf Count</label><input id="wolf-count" type="number" class="form-input" value="${room.settings.wolfCount}" min="1"></div>
                                        <div><label for="turn-count" class="font-medium">Rounds</label><input id="turn-count" type="number" class="form-input" value="${room.settings.turnCount}" min="1" max="5"></div>
                                        <div><label for="talk-time" class="font-medium">Talk Time (sec)</label><input id="talk-time" type="number" class="form-input" value="${room.settings.talkTime}" min="10"></div>
                                        <div><label for="final-talk-time" class="font-medium">Final Talk (sec)</label><input id="final-talk-time" type="number" class="form-input" value="${room.settings.finalTalkTime}" min="10"></div>
                                        <div><label for="voting-time" class="font-medium">Voting Time (sec)</label><input id="voting-time" type="number" class="form-input" value="${room.settings.votingTime}" min="10"></div>
                                    </div>
                                    <div>
                                        <label for="topic" class="font-medium">Topic</label>
                                        <select id="topic" class="form-select">
                                            <option value="ai_choice" ${room.settings.topic === 'ai_choice' ? 'selected' : ''}>AI Choice</option>
                                            ${Object.keys(topicNames).map(key => `<option value="${key}" ${room.settings.topic === key ? 'selected' : ''}>${topicNames[key]}</option>`).join('')}
                                            <option value="custom" ${room.settings.topic === 'custom' ? 'selected' : ''}>Custom</option>
                                        </select>
                                    </div>
                                    <div id="ai-choice-area" class="hidden space-y-2">
                                        <label for="ai-category" class="font-medium">Select a category for AI</label>
                                        <select id="ai-category" class="form-select">${topicOptionsHTML}</select>
                                        <button id="generate-ai-btn" class="btn btn-secondary w-full">Generate with AI</button>
                                        <div id="ai-result-area" class="text-center p-2"></div>
                                    </div>
                                    <div id="custom-topic-area" class="hidden space-y-2">
                                        <label for="custom-category-name" class="font-medium">Custom Category Name</label>
                                        <input id="custom-category-name" type="text" class="form-input" placeholder="e.g., Marvel Superheroes">
                                        <label for="custom-word-list" class="font-medium">Word List (comma separated)</label>
                                        <textarea id="custom-word-list" class="form-textarea" rows="3" placeholder="e.g., Iron Man, Captain America, Thor, Hulk"></textarea>
                                    </div>
                                </div>
                                <button id="start-game-btn" class="btn btn-primary w-full mt-6">Start Game</button>
                            ` : '<p class="text-gray-300 mt-6">Waiting for the host to start the game...</p>'}
                        </div>
                    </div>
                `;
            }

            getRoleAssignmentHTML(room) {
                const me = room.players[this.localState.userId];
                return `
                    <div class="screen">
                        <div class="card text-center">
                            <p class="text-gray-300 mt-6">Your Word is</p>
                            <p class="text-4xl font-bold text-violet-400 my-4">${me.word}</p>
                            <button id="ack-word-btn" class="btn btn-primary w-full">I Understand</button>
                        </div>
                    </div>
                `;
            }

            getTalkTimeHTML(room) {
                const sortedPlayers = Object.values(room.players).sort((a, b) => a.joinedAt - b.joinedAt);
                const playersHTML = sortedPlayers.map(p => {
                    const isEliminated = p.isEliminated ? 'line-through opacity-50' : '';
                    return `<span class="p-2 rounded-full bg-gray-700 ${isEliminated}">${p.name}</span>`;
                }).join('');
                const title = room.gameState === 'final_talk_time' ? 'Final Talk Time' : 'Talk Time';
                return `
                    <div class="screen">
                        <div class="card text-center w-full max-w-2xl">
                            <p class="text-2xl font-bold mb-4">${title} (Round ${room.currentTurn})</p>
                            <div id="timer-display" class="timer text-violet-400 mb-6">00:00</div>
                            <p class="font-medium mb-2">Participants</p>
                            <div class="flex flex-wrap justify-center gap-2">${playersHTML}</div>
                        </div>
                    </div>
                `;
            }

            getQuestionTimeHTML(room) {
                const questionerId = room.questionerOrder[room.currentQuestionerIndex];
                const questioner = room.players[questionerId];
                const isMyTurn = questionerId === this.localState.userId;

                return `
                    <div class="screen">
                        <div class="card text-center">
                            <h2 class="text-3xl font-bold mb-4">Question Time</h2>
                            <p class="text-gray-300 mb-6">It's <span class="font-bold text-violet-400">${questioner.name}'s</span> turn to ask a question.</p>
                            ${isMyTurn ? `
                                <p class="mb-4">Ask one person a question, or skip your turn.</p>
                                <div class="flex gap-4">
                                    <button id="next-questioner-btn" class="btn btn-primary w-full">Next Questioner</button>
                                    <button id="skip-question-btn" class="btn btn-secondary w-full">Skip</button>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }

            getVotingHTML(room) {
                const me = room.players[this.localState.userId];
                const isHost = room.hostId === this.localState.userId;

                if (me.isEliminated || (room.votes && room.votes[this.localState.userId])) {
                    return `<div class="screen"><div class="card text-center"><p class="text-xl">Vote complete. Waiting for others...</p></div></div>`;
                }
                
                const voteButtonsHTML = Object.entries(room.players)
                    .filter(([key, p]) => !p.isEliminated)
                    .sort(([keyA, pA], [keyB, pB]) => pA.joinedAt - pB.joinedAt)
                    .map(([key, p]) => `<button class="btn btn-secondary w-full" data-vote-id="${key}" data-vote-name="${p.name}" ${key === this.localState.userId ? 'disabled' : ''}>${p.name}</button>`)
                    .join('');

                return `
                    <div class="screen">
                        <div class="card text-center">
                            <h2 class="text-3xl font-bold mb-4">Vote Time (Round ${room.currentTurn})</h2>
                            <div id="timer-display" class="timer text-violet-400 mb-4">00:00</div>
                            <p class="text-gray-300 mb-6">Who do you think is the Wolf?</p>
                            <div id="vote-buttons-container" class="grid grid-cols-2 sm:grid-cols-3 gap-3">${voteButtonsHTML}</div>
                            ${isHost ? `<div class="mt-6 text-lg border-t border-gray-700 pt-4">Voted: <span id="voted-count">0</span> / <span id="total-voters">0</span></div>` : ''}
                            <div id="vote-confirmation-area" class="hidden mt-6 space-y-4 border-t border-gray-700 pt-4">
                                <p id="vote-confirm-text" class="text-lg"></p>
                                <div class="flex gap-4">
                                    <button id="confirm-vote-btn" class="btn btn-primary w-full">Confirm</button>
                                    <button id="cancel-vote-btn" class="btn btn-secondary w-full">Cancel</button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            getResultsHTML(room) {
                const eliminatedPlayer = room.lastEliminatedId ? room.players[room.lastEliminatedId] : null;
                let resultText = "The vote was a tie. No one was eliminated.";
                let roleRevealHTML = '';
                if (eliminatedPlayer) {
                    resultText = `${eliminatedPlayer.name} has been voted out.`;
                    const roleColor = eliminatedPlayer.role === 'wolf' ? 'text-red-500' : 'text-blue-500';
                    roleRevealHTML = `<p class="text-xl">${eliminatedPlayer.name} was a <span class="font-bold ${roleColor}">${eliminatedPlayer.role}</span>.</p>`;
                }
                const isHost = room.hostId === this.localState.userId;
                return `
                    <div class="screen">
                        <div class="card text-center">
                            <h2 class="text-3xl font-bold mb-4">Vote Results</h2>
                            <p class="text-xl mb-6">${resultText}</p>
                            ${roleRevealHTML}
                            ${isHost ? '<button id="next-round-btn" class="btn btn-primary w-full mt-6">Continue</button>' : '<p class="text-gray-300 mt-6">Waiting for the host to continue...</p>'}
                        </div>
                    </div>
                `;
            }

            getWolfGuessHTML(room) {
                const guessingWolf = room.players[room.lastEliminatedId];
                const isMyTurn = this.localState.userId === room.lastEliminatedId;

                return `
                    <div class="screen">
                        <div class="card text-center">
                            <h2 class="text-3xl font-bold mb-2">Wolf's Final Guess!</h2>
                            <p class="text-gray-300 mb-6">${guessingWolf.name}, guess the Citizen's word for a comeback victory!</p>
                            ${isMyTurn ? `
                                <input id="wolf-guess-input" type="text" class="form-input text-center mb-4" placeholder="Enter Citizen's word">
                                <button id="submit-guess-btn" class="btn btn-primary w-full">Submit Guess</button>
                            ` : `<p>Waiting for ${guessingWolf.name} to guess...</p>`}
                        </div>
                    </div>
                `;
            }

            getEndGameHTML(room) {
                return `
                    <div class="screen">
                        <div class="card text-center">
                            <h2 class="text-4xl font-bold ${room.winner === 'citizens' ? 'text-blue-500' : 'text-red-500'}">${room.winner.charAt(0).toUpperCase() + room.winner.slice(1)} Win!</h2>
                            <p class="my-6">The words were:</p>
                            <div class="text-lg bg-gray-900 p-4 rounded-lg">
                                <p>Citizen: <span class="font-bold">${room.words.citizen}</span></p>
                                <p>Wolf: <span class="font-bold">${room.words.wolf}</span></p>
                            </div>
                            ${room.hostId === this.localState.userId ? '<button id="play-again-btn" class="btn btn-primary w-full mt-6">Play Again</button>' : '<p class="text-gray-300 mt-6">Waiting for the host...</p>'}
                        </div>
                    </div>
                `;
            }
            
            addHomeListeners() {
                document.getElementById('create-room-btn').addEventListener('click', () => this.createRoom());
                document.getElementById('join-room-btn').addEventListener('click', () => this.joinRoom(null));
                document.getElementById('show-rules-btn').addEventListener('click', () => {
                    this.render(this.getRulesAndCreditsHTML());
                    document.getElementById('back-to-home-btn').addEventListener('click', () => {
                        this.renderHomeScreen();
                    });
                });
            }
            
            addWaitingRoomListeners(room) {
                if (this.localState.isHost) {
                    const settingsToWatch = ['language', 'wolf-count', 'turn-count', 'talk-time', 'final-talk-time', 'voting-time', 'topic'];
                    settingsToWatch.forEach(id => {
                        const el = document.getElementById(id);
                        if (el) el.addEventListener('change', () => this.updateSettings(room.id));
                    });
                    
                    document.getElementById('start-game-btn').addEventListener('click', () => this.startGame(room));
                    document.getElementById('generate-ai-btn').addEventListener('click', () => this.handleAiGeneration());
                    
                    const topicSelect = document.getElementById('topic');
                    topicSelect.addEventListener('change', () => {
                        const customArea = document.getElementById('custom-topic-area');
                        const aiArea = document.getElementById('ai-choice-area');
                        if (topicSelect.value === 'custom') {
                            customArea.classList.remove('hidden');
                            aiArea.classList.add('hidden');
                        } else if (topicSelect.value === 'ai_choice') {
                            customArea.classList.add('hidden');
                            aiArea.classList.remove('hidden');
                        } else {
                            customArea.classList.add('hidden');
                            aiArea.classList.add('hidden');
                        }
                    });
                    topicSelect.dispatchEvent(new Event('change'));
                }
                document.getElementById('room-id-display').addEventListener('click', (e) => {
                    navigator.clipboard.writeText(room.id);
                    document.getElementById('copy-feedback').textContent = 'Copied!';
                    setTimeout(() => { if(document.getElementById('copy-feedback')) document.getElementById('copy-feedback').textContent = '' }, 2000);
                });
            }

            addRoleAssignmentListeners(room) {
                document.getElementById('ack-word-btn').addEventListener('click', () => this.handleAcknowledgement(room));
            }

            addQuestionTimeListeners(room) {
                const isMyTurn = room.questionerOrder[room.currentQuestionerIndex] === this.localState.userId;
                if (isMyTurn) {
                    document.getElementById('next-questioner-btn').addEventListener('click', () => this.handleQuestionTurn(room));
                    document.getElementById('skip-question-btn').addEventListener('click', () => this.handleQuestionTurn(room));
                }
            }
            
            addVotingListeners(room) {
                if (room.players[this.localState.userId]?.isEliminated || (room.votes && room.votes[this.localState.userId])) return;
                
                let selectedVoteId = null;
                const confirmationArea = document.getElementById('vote-confirmation-area');
                const confirmText = document.getElementById('vote-confirm-text');
                const confirmBtn = document.getElementById('confirm-vote-btn');
                const cancelBtn = document.getElementById('cancel-vote-btn');

                document.querySelectorAll('[data-vote-id]').forEach(button => {
                    button.addEventListener('click', (e) => {
                        selectedVoteId = e.currentTarget.dataset.voteId;
                        const selectedName = e.currentTarget.dataset.voteName;
                        
                        document.querySelectorAll('[data-vote-id]').forEach(btn => btn.disabled = true);
                        e.currentTarget.classList.remove('btn-secondary');
                        e.currentTarget.classList.add('btn-primary');

                        confirmText.textContent = `Vote for ${selectedName}?`;
                        confirmationArea.classList.remove('hidden');
                    });
                });

                cancelBtn.addEventListener('click', () => {
                    selectedVoteId = null;
                    document.querySelectorAll('[data-vote-id]').forEach(btn => {
                        btn.disabled = (btn.dataset.voteId === this.localState.userId);
                        btn.classList.remove('btn-primary');
                        btn.classList.add('btn-secondary');
                    });
                    confirmationArea.classList.add('hidden');
                });

                confirmBtn.addEventListener('click', () => {
                    if (selectedVoteId) {
                        this.render(`<div class="screen"><div class="card text-center"><p class="text-xl">You have voted. Waiting for others...</p></div></div>`);
                        this.handleVote(selectedVoteId);
                    }
                });
            }

            addResultsListeners(room) {
                if (!this.localState.isHost) return;
                document.getElementById('next-round-btn').addEventListener('click', async () => {
                    const roomRef = this.getRoomRef(room.id);
                    const remainingPlayers = Object.values(room.players).filter(p => !p.isEliminated);
                    const remainingWolves = remainingPlayers.filter(p => p.role === 'wolf').length;
                    const remainingCitizens = remainingPlayers.length - remainingWolves;
                    const currentTurn = room.currentTurn || 1;
                    const maxTurns = room.settings.turnCount || 1;

                    if (remainingWolves === 0) {
                        if (room.lastEliminatedId && room.players[room.lastEliminatedId].role === 'wolf' && room.settings.wolfCount === 1) {
                            await updateDoc(roomRef, { gameState: 'wolf_guess' });
                        } else {
                            await updateDoc(roomRef, { gameState: 'end_game', winner: 'citizens' });
                        }
                    } 
                    else if (remainingWolves >= remainingCitizens) {
                        await updateDoc(roomRef, { gameState: 'end_game', winner: 'wolves' });
                    } 
                    else if (currentTurn >= maxTurns) {
                        await updateDoc(roomRef, { gameState: 'end_game', winner: 'wolves' });
                    } 
                    else {
                        const talkTimeInSeconds = room.settings.talkTime || 180;
                        const phaseEndTime = new Date(Date.now() + talkTimeInSeconds * 1000);
                        const newQuestionerOrder = remainingPlayers.map(p => p.id).sort(() => 0.5 - Math.random());
                        await updateDoc(roomRef, { 
                            gameState: 'talk_time', phaseEndTime, lastEliminatedId: null,
                            currentTurn: currentTurn + 1, questionerOrder: newQuestionerOrder, currentQuestionerIndex: 0
                        });
                    }
                });
            }

            addWolfGuessListeners(room) {
                if (this.localState.userId !== room.lastEliminatedId) return;
                document.getElementById('submit-guess-btn').addEventListener('click', async () => {
                    const guess = document.getElementById('wolf-guess-input').value.trim();
                    const roomRef = this.getRoomRef(room.id);
                    if (guess.toLowerCase() === room.words.citizen.toLowerCase()) {
                        await updateDoc(roomRef, { gameState: 'end_game', winner: 'wolves' });
                    } else {
                        await updateDoc(roomRef, { gameState: 'end_game', winner: 'citizens' });
                    }
                });
            }

            addEndGameListeners(room) {
                if (!this.localState.isHost) return;
                document.getElementById('play-again-btn').addEventListener('click', async () => {
                    const roomRef = this.getRoomRef(room.id);
                    const playersReset = {};
                    Object.keys(room.players).forEach(id => {
                        playersReset[id] = { name: room.players[id].name, isHost: room.players[id].isHost, joinedAt: room.players[id].joinedAt };
                    });
                    await updateDoc(roomRef, {
                        gameState: 'waiting', players: playersReset, lastEliminatedId: null, winner: null,
                        words: null, currentTurn: null, questionerOrder: null, currentQuestionerIndex: null,
                    });
                });
            }

            getRoomRef(roomId) {
                return doc(this.db, "rooms", roomId);
            }

            attachRoomListener(roomId) {
                this.localState.roomId = roomId;
                if (this.localState.roomUnsubscribe) this.localState.roomUnsubscribe();
                
                const roomRef = this.getRoomRef(roomId);
                this.localState.roomUnsubscribe = onSnapshot(roomRef, (doc) => {
                    const roomData = doc.data();
                    if (!roomData) {
                        if (this.localState.roomUnsubscribe) this.localState.roomUnsubscribe();
                        localStorage.removeItem('wordWolfRoomId');
                        this.showMessage("The host has closed the room.", () => { window.location.href = '/'; });
                        return;
                    }

                    this.localState.isHost = roomData.hostId === this.localState.userId;
                    
                    if (this.localState.timerInterval && !['talk_time', 'final_talk_time', 'voting'].includes(roomData.gameState)) {
                        clearInterval(this.localState.timerInterval);
                    }

                    this.routeGameState(roomData);
                });
            }

            routeGameState(roomData) {
                 switch (roomData.gameState) {
                    case 'waiting': 
                        this.render(this.getWaitingRoomHTML(roomData)); 
                        this.addWaitingRoomListeners(roomData); 
                        break;
                    case 'role_assignment':
                        const me = roomData.players[this.localState.userId];
                        if (me && me.acknowledged) {
                            this.render(`<div class="screen"><div class="card text-center"><p class="text-xl">Waiting for other players to confirm...</p></div></div>`);
                        } else {
                            this.render(this.getRoleAssignmentHTML(roomData)); 
                            this.addRoleAssignmentListeners(roomData);
                        }
                        break;
                    case 'talk_time':
                    case 'final_talk_time': 
                        this.render(this.getTalkTimeHTML(roomData)); 
                        this.handlePhaseTimer(roomData); 
                        break;
                    case 'question_time': 
                        this.render(this.getQuestionTimeHTML(roomData)); 
                        this.addQuestionTimeListeners(roomData); 
                        break;
                    case 'voting': 
                        this.render(this.getVotingHTML(roomData)); 
                        this.addVotingListeners(roomData); 
                        this.handlePhaseTimer(roomData); 
                        break;
                    case 'results': 
                        this.render(this.getResultsHTML(roomData)); 
                        this.addResultsListeners(roomData); 
                        break;
                    case 'wolf_guess': 
                        this.render(this.getWolfGuessHTML(roomData)); 
                        this.addWolfGuessListeners(roomData); 
                        break;
                    case 'end_game':
                        localStorage.removeItem('wordWolfRoomId');
                        this.render(this.getEndGameHTML(roomData)); 
                        this.addEndGameListeners(roomData); 
                        break;
                }
            }
            
            async createRoom() {
                if (!this.validatePlayerName()) return;
                this.localState.isHost = true;
                const roomId = Math.random().toString(36).substring(2, 8).toUpperCase();
                window.history.pushState({}, '', `/room/${roomId}`);
                const roomRef = this.getRoomRef(roomId);
                const newPlayer = { [this.localState.userId]: { name: this.localState.playerName, isHost: true, joinedAt: Date.now() } };
                await setDoc(roomRef, {
                    id: roomId, hostId: this.localState.userId, gameState: 'waiting', players: newPlayer,
                    settings: { wolfCount: 1, topic: 'ai_choice', language: 'en', turnCount: 1, talkTime: 180, finalTalkTime: 60, votingTime: 30 }
                });
                this.localState.roomId = roomId;
                localStorage.setItem('wordWolfRoomId', roomId);
                this.attachRoomListener(roomId);
            }

            async joinRoom(roomIdFromUrl) {
                let roomId = roomIdFromUrl;
                if (!roomId) {
                    const joinIdInput = document.getElementById('join-room-id-input');
                    if (joinIdInput) {
                        const joinId = joinIdInput.value.trim().toUpperCase();
                        if(!joinId) { this.showMessage('Please enter a Room ID.'); return; }
                        roomId = joinId;
                    } else {
                        return;
                    }
                }
                if (!this.validatePlayerName()) return;
                
                const roomRef = this.getRoomRef(roomId);
                const roomSnap = await getDoc(roomRef);

                if (!roomSnap.exists()) {
                    this.showMessage("Room not found!");
                    localStorage.removeItem('wordWolfRoomId');
                    return;
                }
                
                window.history.pushState({}, '', `/room/${roomId}`);
                const newPlayerData = { name: this.localState.playerName, isHost: roomSnap.data().hostId === this.localState.userId, joinedAt: Date.now() };
                await updateDoc(roomRef, { [`players.${this.localState.userId}`]: newPlayerData });
                
                this.localState.roomId = roomId;
                localStorage.setItem('wordWolfRoomId', roomId);
                this.attachRoomListener(roomId);
            }

            async startGame(room) {
                const roomRef = this.getRoomRef(room.id);
                const players = room.players;
                const settings = room.settings;
                const playerIds = Object.keys(players);
                
                if (playerIds.length < 3) {
                    this.showMessage("You need at least 3 players to start.");
                    return;
                }
                
                let wordPair;

                try {
                    if (settings.topic === 'custom') {
                        const wordList = (document.getElementById('custom-word-list').value || '').split(',')
                            .map(w => w.trim()).filter(w => w);
                        if (wordList.length < 2) {
                            this.showMessage("Custom topic needs at least 2 comma-separated words.");
                            return;
                        }
                        const shuffled = wordList.sort(() => 0.5 - Math.random());
                        wordPair = shuffled.slice(0, 2);
                    } else if (settings.topic === 'ai_choice') {
                        if (!this.localState.aiGeneratedPair) {
                            this.showMessage("Please generate a word pair with AI first.");
                            return;
                        }
                        wordPair = this.localState.aiGeneratedPair;
                    } else {
                        const topicData = settings.language === 'ja' ? TOPICS_JA : TOPICS_EN;
                        wordPair = topicData[settings.topic][Math.floor(Math.random() * topicData[settings.topic].length)];
                    }
                } catch (error) {
                    this.showMessage("Could not set up the words for the game. Please check the topic settings.");
                    console.error(error);
                    return;
                }

                const wolfCount = Math.max(1, Math.min(settings.wolfCount, playerIds.length - 1));
                let roles = Array(playerIds.length).fill('citizen');
                for(let i = 0; i < wolfCount; i++) roles[i] = 'wolf';
                roles.sort(() => 0.5 - Math.random());
                
                const [wordA, wordB] = wordPair.sort(() => 0.5 - Math.random());
                
                const updatedPlayers = { ...players };
                playerIds.forEach((id, index) => {
                    updatedPlayers[id].role = roles[index];
                    updatedPlayers[id].word = roles[index] === 'wolf' ? wordB : wordA;
                    updatedPlayers[id].acknowledged = false;
                });
                
                const questionerOrder = [...playerIds].sort(() => 0.5 - Math.random());
                
                await updateDoc(roomRef, {
                    gameState: 'role_assignment',
                    players: updatedPlayers,
                    words: { citizen: wordA, wolf: wordB },
                    currentTurn: 1,
                    questionerOrder: questionerOrder,
                    currentQuestionerIndex: 0,
                    votes: {}
                });
            }

            async handleAcknowledgement(room) {
                const roomRef = this.getRoomRef(room.id);
                await runTransaction(this.db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    if (!roomSnap.exists()) { throw "Room does not exist!"; }
                    
                    const currentRoom = roomSnap.data();
                    const updatedPlayers = { ...currentRoom.players };
                    if(updatedPlayers[this.localState.userId]) {
                       updatedPlayers[this.localState.userId].acknowledged = true;
                    }
                    
                    transaction.update(roomRef, { players: updatedPlayers });

                    const allAckd = Object.values(updatedPlayers).every(p => p.acknowledged);
                    if (allAckd) {
                        const talkTimeInSeconds = currentRoom.settings.talkTime || 180;
                        const phaseEndTime = new Date(Date.now() + talkTimeInSeconds * 1000);
                        transaction.update(roomRef, { 
                            gameState: 'talk_time',
                            phaseEndTime: phaseEndTime
                        });
                    }
                });
            }

            async handleQuestionTurn(room) {
                const roomRef = this.getRoomRef(room.id);
                const nextIndex = room.currentQuestionerIndex + 1;
                
                if (nextIndex >= room.questionerOrder.length) {
                    const finalTalkTimeInSeconds = room.settings.finalTalkTime || 60;
                    const phaseEndTime = new Date(Date.now() + finalTalkTimeInSeconds * 1000);
                    await updateDoc(roomRef, { gameState: 'final_talk_time', phaseEndTime: phaseEndTime });
                } else {
                    await updateDoc(roomRef, { currentQuestionerIndex: nextIndex });
                }
            }

            async handleVote(votedId) {
                const roomRef = this.getRoomRef(this.localState.roomId);
                await updateDoc(roomRef, {
                    [`votes.${this.localState.userId}`]: votedId
                });
            }

            handlePhaseTimer(room) {
                if (this.localState.timerInterval) clearInterval(this.localState.timerInterval);
                const timerDisplay = document.getElementById('timer-display');
                if (!timerDisplay) return;

                const votedCountEl = document.getElementById('voted-count');
                const totalVotersEl = document.getElementById('total-voters');

                this.localState.timerInterval = setInterval(async () => {
                    if (!room.phaseEndTime) { clearInterval(this.localState.timerInterval); return; }

                    const serverTime = room.phaseEndTime.toMillis();
                    const remaining = Math.max(0, Math.round((serverTime - Date.now()) / 1000));
                    const minutes = String(Math.floor(remaining / 60)).padStart(2, '0');
                    const seconds = String(remaining % 60).padStart(2, '0');
                    if (timerDisplay) timerDisplay.textContent = `${minutes}:${seconds}`;

                    if (room.gameState === 'voting' && this.localState.isHost && votedCountEl) {
                        const totalVoters = Object.values(room.players).filter(p => !p.isEliminated).length;
                        const votedCount = Object.keys(room.votes || {}).length;
                        votedCountEl.textContent = votedCount;
                        totalVotersEl.textContent = totalVoters;
                    }

                    if (remaining <= 0 && this.localState.isHost) {
                        clearInterval(this.localState.timerInterval);
                        const roomRef = this.getRoomRef(room.id);
                        const currentRoomSnap = await getDoc(roomRef);
                        const currentRoom = currentRoomSnap.data();

                        if (currentRoom.gameState !== room.gameState) return;

                        switch (currentRoom.gameState) {
                            case 'talk_time':
                                await updateDoc(roomRef, { gameState: 'question_time' }); break;
                            case 'final_talk_time':
                                const votingTime = currentRoom.settings.votingTime || 30;
                                const phaseEndTime = new Date(Date.now() + votingTime * 1000);
                                await updateDoc(roomRef, { gameState: 'voting', phaseEndTime }); break;
                        }
                    }
                }, 500);
            }
            
            validatePlayerName() {
                const nameInput = document.getElementById('player-name-input');
                if (!nameInput) return true;
                const playerName = nameInput.value.trim();
                if (!playerName) { this.showMessage('Please enter your name.'); return false; }
                this.localState.playerName = playerName;
                localStorage.setItem('playerName', playerName);
                return true;
            }

            async updateSettings(roomId) {
                const roomRef = this.getRoomRef(roomId);
                await updateDoc(roomRef, {
                    "settings.wolfCount": parseInt(document.getElementById('wolf-count').value) || 1,
                    "settings.turnCount": parseInt(document.getElementById('turn-count').value) || 1,
                    "settings.talkTime": parseInt(document.getElementById('talk-time').value) || 180,
                    "settings.finalTalkTime": parseInt(document.getElementById('final-talk-time').value) || 60,
                    "settings.votingTime": parseInt(document.getElementById('voting-time').value) || 30,
                    "settings.topic": document.getElementById('topic').value,
                    "settings.language": document.getElementById('language').value,
                });
            }

            async handleAiGeneration() {
                const categorySelect = document.getElementById('ai-category');
                const categoryName = categorySelect.options[categorySelect.selectedIndex].text;
                const resultArea = document.getElementById('ai-result-area');
                const generateBtn = document.getElementById('generate-ai-btn');

                resultArea.innerHTML = '<div class="loader"></div>';
                generateBtn.disabled = true;
                this.localState.aiGeneratedPair = null;

                const prompt = `For the game 'Word Wolf', generate a single, clever pair of words from the category '${categoryName}'. The words should be very similar but have a subtle difference. Respond with only the two words separated by a comma, without any extra text or formatting. For example: Curry,Stew`;
                
                try {
                    const apiKey = ""; 
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                    const payload = { contents: [{ parts: [{ text: prompt }] }] };

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) throw new Error(`API Error: ${response.statusText}`);

                    const result = await response.json();
                    const text = result.candidates[0].content.parts[0].text;
                    const pair = text.split(',').map(w => w.trim());

                    if (pair.length !== 2) throw new Error("AI did not return a valid pair.");

                    this.localState.aiGeneratedPair = pair;
                    resultArea.innerHTML = `<p class="text-green-400">Generated: <span class="font-bold">${pair[0]}</span> & <span class="font-bold">${pair[1]}</span></p>`;

                } catch (error) {
                    console.error("AI Generation Error:", error);
                    resultArea.innerHTML = `<p class="text-red-400">Failed to generate. Please try again.</p>`;
                } finally {
                    generateBtn.disabled = false;
                }
            }

            setupModalListeners() {
                this.messageBoxContainer = document.getElementById('message-box-container');
                this.messageBoxText = document.getElementById('message-box-text');
                this.messageBoxCloseBtn = document.getElementById('message-box-close');
                this.messageBoxCallback = null;

                this.messageBoxCloseBtn.addEventListener('click', () => {
                    this.messageBoxContainer.classList.remove('visible');
                    if (this.messageBoxCallback) this.messageBoxCallback();
                });

                this.rejoinPromptContainer = document.getElementById('rejoin-prompt-container');
                this.rejoinPromptText = document.getElementById('rejoin-prompt-text');
                this.rejoinConfirmBtn = document.getElementById('rejoin-confirm-btn');
                this.rejoinCancelBtn = document.getElementById('rejoin-cancel-btn');
            }

            showMessage(message, callback) {
                this.messageBoxText.textContent = message;
                this.messageBoxCallback = callback || null;
                this.messageBoxContainer.classList.add('visible');
            }

            showRejoinPrompt(roomId, onConfirm, onCancel) {
                this.rejoinPromptText.textContent = `You were in Room ${roomId}. Would you like to rejoin?`;
                this.rejoinConfirmBtn.onclick = () => { this.rejoinPromptContainer.classList.remove('visible'); onConfirm(); };
                this.rejoinCancelBtn.onclick = () => { this.rejoinPromptContainer.classList.remove('visible'); onCancel(); };
                this.rejoinPromptContainer.classList.add('visible');
            }
        }

        window.onload = () => {
            new WordWolfGame();
        };

    </script>
</body>
</html>
